(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global["onflowUtil-actor"] = {}));
})(this, (function (exports) { 'use strict';

  const mailbox = () => {
    const queue = [];
    let next;
    return {
      async deliver(msg) {
        queue.push(msg);
        if (next) {
          next(queue.shift());
          next = undefined;
        }
      },
      receive() {
        return new Promise(function innerReceive(resolve) {
          const msg = queue.shift();
          if (msg) return resolve(msg);
          next = resolve;
        });
      }
    };
  };

  let promise;
  const _queueMicrotask = cb => (promise || (promise = Promise.resolve())).then(cb).catch(err => setTimeout(() => {
    throw err;
  }, 0));
  const INIT = "INIT";
  const SUBSCRIBE = "SUBSCRIBE";
  const UNSUBSCRIBE = "UNSUBSCRIBE";
  const UPDATED = "UPDATED";
  const SNAPSHOT = "SNAPSHOT";
  const EXIT = "EXIT";
  const TERMINATE = "TERMINATE";
  const root = typeof self === "object" && self.self === self && self || typeof global === "object" && global.global === global && global || typeof window === "object" && window.window === window && window || {
    FCL_REGISTRY: null
  };
  root.FCL_REGISTRY = root.FCL_REGISTRY == null ? {} : root.FCL_REGISTRY;
  const FCL_REGISTRY = root.FCL_REGISTRY;
  let pid = 0b0;
  const DEFAULT_TIMEOUT = 5000;
  function send(addr, tag, data) {
    let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {
      expectReply: false
    };
    return new Promise((resolve, reject) => {
      const expectReply = opts.expectReply || false;
      const timeout = opts.timeout != null ? opts.timeout : DEFAULT_TIMEOUT;
      if (expectReply && timeout) {
        setTimeout(() => reject(new Error(`Timeout: ${timeout}ms passed without a response.`)), timeout);
      }
      const payload = {
        to: addr,
        from: opts.from,
        tag,
        data,
        timeout,
        reply: resolve,
        reject
      };
      try {
        if (FCL_REGISTRY[addr]) {
          FCL_REGISTRY[addr].mailbox.deliver(payload);
        }
        if (!expectReply) {
          resolve(true);
        }
      } catch (error) {
        console.error("FCL.Actor -- Could Not Deliver Message", payload, FCL_REGISTRY[addr], error);
        reject(error);
      }
    });
  }
  const kill = addr => {
    delete FCL_REGISTRY[addr];
  };
  const fromHandlers = handlers => async ctx => {
    if (typeof handlers[INIT] === "function") await handlers[INIT](ctx);
    __loop: while (1) {
      const letter = await ctx.receive();
      try {
        if (letter.tag === EXIT) {
          if (typeof handlers[TERMINATE] === "function") {
            await handlers[TERMINATE](ctx, letter, letter.data || {});
          }
          break __loop;
        }
        await handlers[letter.tag]?.(ctx, letter, letter.data || {});
      } catch (error) {
        console.error(`${ctx.self()} Error`, letter, error);
      } finally {
        continue __loop;
      }
    }
  };
  const parseAddr = addr => {
    if (addr == null) {
      while (FCL_REGISTRY[String(pid)]) {
        pid++;
      }
      return String(pid);
    }
    return String(addr);
  };
  const spawn = function (fnOrHandlers) {
    let rawAddr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    const addr = parseAddr(rawAddr);
    if (FCL_REGISTRY[addr] != null) return addr;
    FCL_REGISTRY[addr] = {
      addr,
      mailbox: mailbox(),
      subs: new Set(),
      kvs: {},
      error: null
    };
    const ctx = createCtx(addr);
    let fn;
    if (typeof fnOrHandlers === "object") fn = fromHandlers(fnOrHandlers);else fn = fnOrHandlers;
    _queueMicrotask(async () => {
      await fn(ctx);
      kill(addr);
    });
    return addr;
  };
  const createCtx = addr => ({
    self: () => addr,
    receive: () => FCL_REGISTRY[addr].mailbox.receive(),
    send: function (to, tag, data) {
      let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      if (to == null) return;
      opts.from = addr;
      return send(to, tag, data, opts);
    },
    sendSelf: function (tag, data) {
      let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      if (FCL_REGISTRY[addr]) send(addr, tag, data, opts);
    },
    broadcast: function (tag, data) {
      let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      opts.from = addr;
      for (const to of FCL_REGISTRY[addr].subs) send(to, tag, data, opts);
    },
    subscribe: sub => sub != null && FCL_REGISTRY[addr].subs.add(sub),
    unsubscribe: sub => sub != null && FCL_REGISTRY[addr].subs.delete(sub),
    subscriberCount: () => FCL_REGISTRY[addr].subs.size,
    hasSubs: () => !!FCL_REGISTRY[addr].subs.size,
    put: (key, value) => {
      if (key != null) FCL_REGISTRY[addr].kvs[key] = value;
    },
    get: function (key) {
      let fallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      const value = FCL_REGISTRY[addr].kvs[key];
      return value == null ? fallback : value;
    },
    delete: key => {
      delete FCL_REGISTRY[addr].kvs[key];
    },
    update: (key, fn) => {
      if (key != null) FCL_REGISTRY[addr].kvs[key] = fn(FCL_REGISTRY[addr].kvs[key]);
    },
    keys: () => {
      return Object.keys(FCL_REGISTRY[addr].kvs);
    },
    all: () => {
      return FCL_REGISTRY[addr].kvs;
    },
    where: pattern => {
      return Object.keys(FCL_REGISTRY[addr].kvs).reduce((acc, key) => {
        return pattern.test(key) ? {
          ...acc,
          [key]: FCL_REGISTRY[addr].kvs[key]
        } : acc;
      }, {});
    },
    merge: function () {
      let data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      Object.keys(data).forEach(key => FCL_REGISTRY[addr].kvs[key] = data[key]);
    },
    fatalError: error => {
      FCL_REGISTRY[addr].error = error;
      for (const to of FCL_REGISTRY[addr].subs) send(to, UPDATED);
    }
  });

  // Returns an unsubscribe function
  // A SUBSCRIBE handler will need to be created to handle the subscription event
  //
  //  [SUBSCRIBE]: (ctx, letter) => {
  //    ctx.subscribe(letter.from)
  //    ctx.send(letter.from, UPDATED, ctx.all())
  //  }
  //
  function subscriber(address, spawnFn, callback) {
    spawnFn(address);
    const self = spawn(async ctx => {
      ctx.send(address, SUBSCRIBE);
      while (1) {
        const letter = await ctx.receive();
        const error = FCL_REGISTRY[address].error;
        if (letter.tag === EXIT) {
          ctx.send(address, UNSUBSCRIBE);
          return;
        }
        if (error) {
          callback(null, error);
          ctx.send(address, UNSUBSCRIBE);
          return;
        }
        callback(letter.data, null);
      }
    });
    return () => send(self, EXIT);
  }

  // Returns a promise that returns a result
  // A SNAPSHOT handler will need to be created to handle the snapshot event
  //
  //  [SNAPSHOT]: (ctx, letter) => {
  //    letter.reply(ctx.all())
  //  }
  //
  function snapshoter(address, spawnFn) {
    spawnFn(address);
    return send(address, SNAPSHOT, null, {
      expectReply: true,
      timeout: 0
    });
  }

  exports.EXIT = EXIT;
  exports.INIT = INIT;
  exports.SNAPSHOT = SNAPSHOT;
  exports.SUBSCRIBE = SUBSCRIBE;
  exports.TERMINATE = TERMINATE;
  exports.UNSUBSCRIBE = UNSUBSCRIBE;
  exports.UPDATED = UPDATED;
  exports.kill = kill;
  exports.send = send;
  exports.snapshoter = snapshoter;
  exports.spawn = spawn;
  exports.subscriber = subscriber;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=actor.umd.js.map
