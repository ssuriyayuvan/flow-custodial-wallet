import * as logger from '@onflow/util-logger';
import { log, LEVELS } from '@onflow/util-logger';
import { invariant as invariant$1 } from '@onflow/util-invariant';
import { v4 } from 'uuid';
import { InteractionResolverKind, InteractionTag, InteractionStatus, TransactionRole } from '@onflow/typedefs';
import { config } from '@onflow/config';
export { config } from '@onflow/config';
import { Buffer, encode } from '@onflow/rlp';
import { send as send$1 } from '@onflow/transport-http';
import { sansPrefix, withPrefix } from '@onflow/util-address';
import EventEmitter from 'events';
import { SHA3 } from 'sha3';
import { template } from '@onflow/util-template';
export { template as cadence, template as cdc } from '@onflow/util-template';

const ACCT = `{
  "kind":"${InteractionResolverKind.ACCOUNT}",
  "tempId":null,
  "addr":null,
  "keyId":null,
  "sequenceNum":null,
  "signature":null,
  "signingFunction":null,
  "resolve":null,
  "role": {
    "proposer":false,
    "authorizer":false,
    "payer":false,
    "param":false
  }
}`;
const ARG = `{
  "kind":"${InteractionResolverKind.ARGUMENT}",
  "tempId":null,
  "value":null,
  "asArgument":null,
  "xform":null,
  "resolve": null,
  "resolveArgument": null
}`;
const IX = `{
  "tag":"${InteractionTag.UNKNOWN}",
  "assigns":{},
  "status":"${InteractionStatus.OK}",
  "reason":null,
  "accounts":{},
  "params":{},
  "arguments":{},
  "message": {
    "cadence":null,
    "refBlock":null,
    "computeLimit":null,
    "proposer":null,
    "payer":null,
    "authorizations":[],
    "params":[],
    "arguments":[]
  },
  "proposer":null,
  "authorizations":[],
  "payer":[],
  "events": {
    "eventType":null,
    "start":null,
    "end":null,
    "blockIds":[]
  },
  "subscribeEvents": {
    "startBlockId":null,
    "startHeight":null,
    "eventTypes":null,
    "addresses":null,
    "contracts":null,
    "heartbeatInterval":null
  },
  "transaction": {
    "id":null
  },
  "block": {
    "id":null,
    "height":null,
    "isSealed":null
  },
  "account": {
    "addr":null
  },
  "collection": {
    "id":null
  }
}`;
const KEYS = new Set(Object.keys(JSON.parse(IX)));
const initInteraction = () => JSON.parse(IX);
/**
 * @deprecated
 */
const interaction = () => {
  log.deprecate({
    pkg: "FCL/SDK",
    message: `The interaction been deprecated from the Flow JS-SDK/FCL. use initInteraction instead`,
    transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0010-deprecate-interaction",
    level: LEVELS.warn
  });
  return initInteraction();
};
const isNumber$1 = d => typeof d === "number";
const isArray$1 = d => Array.isArray(d);
const isObj = d => d !== null && typeof d === "object";
const isNull = d => d == null;
const isFn$3 = d => typeof d === "function";
const isInteraction = ix => {
  if (!isObj(ix) || isNull(ix) || isNumber$1(ix)) return false;
  for (let key of KEYS) if (!ix.hasOwnProperty(key)) return false;
  return true;
};
const Ok = ix => {
  ix.status = InteractionStatus.OK;
  return ix;
};
const Bad = (ix, reason) => {
  ix.status = InteractionStatus.BAD;
  ix.reason = reason;
  return ix;
};
const makeIx = wat => ix => {
  ix.tag = wat;
  return Ok(ix);
};
const prepAccountKeyId = acct => {
  if (acct.keyId == null) return acct;
  invariant$1(!isNaN(parseInt(acct.keyId.toString())), "account.keyId must be an integer");
  return {
    ...acct,
    keyId: parseInt(acct.keyId.toString())
  };
};
const initAccount = () => JSON.parse(ACCT);
const prepAccount = function (acct) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return ix => {
    invariant$1(typeof acct === "function" || typeof acct === "object", "prepAccount must be passed an authorization function or an account object");
    invariant$1(opts.role != null, "Account must have a role");
    const ACCOUNT = initAccount();
    const role = opts.role;
    const tempId = v4();
    let account = {
      ...acct
    };
    if (acct.authorization && isFn$3(acct.authorization)) account = {
      resolve: acct.authorization
    };
    if (!acct.authorization && isFn$3(acct)) account = {
      resolve: acct
    };
    const resolve = account.resolve;
    if (resolve) {
      account.resolve = function (acct) {
        for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          rest[_key - 1] = arguments[_key];
        }
        return [resolve, prepAccountKeyId].reduce(async (d, fn) => fn(await d, ...rest), acct);
      };
    }
    account = prepAccountKeyId(account);
    ix.accounts[tempId] = {
      ...ACCOUNT,
      tempId,
      ...account,
      role: {
        ...ACCOUNT.role,
        ...(typeof acct.role === "object" ? acct.role : {}),
        ...(role ? {
          [role]: true
        } : {})
      }
    };
    if (role === TransactionRole.AUTHORIZER) {
      ix.authorizations.push(tempId);
    } else if (role === TransactionRole.PAYER) {
      ix.payer.push(tempId);
    } else if (role) {
      ix[role] = tempId;
    }
    return ix;
  };
};
const makeArgument = arg => ix => {
  let tempId = v4();
  ix.message.arguments.push(tempId);
  ix.arguments[tempId] = JSON.parse(ARG);
  ix.arguments[tempId].tempId = tempId;
  ix.arguments[tempId].value = arg.value;
  ix.arguments[tempId].asArgument = arg.asArgument;
  ix.arguments[tempId].xform = arg.xform;
  ix.arguments[tempId].resolve = arg.resolve;
  ix.arguments[tempId].resolveArgument = isFn$3(arg.resolveArgument) ? arg.resolveArgument.bind(arg) : arg.resolveArgument;
  return Ok(ix);
};
const makeUnknown /*                 */ = makeIx(InteractionTag.UNKNOWN);
const makeScript /*                  */ = makeIx(InteractionTag.SCRIPT);
const makeTransaction /*             */ = makeIx(InteractionTag.TRANSACTION);
const makeGetTransactionStatus /*    */ = makeIx(InteractionTag.GET_TRANSACTION_STATUS);
const makeGetTransaction /*          */ = makeIx(InteractionTag.GET_TRANSACTION);
const makeGetAccount /*              */ = makeIx(InteractionTag.GET_ACCOUNT);
const makeGetEvents /*               */ = makeIx(InteractionTag.GET_EVENTS);
const makePing /*                    */ = makeIx(InteractionTag.PING);
const makeGetBlock /*                */ = makeIx(InteractionTag.GET_BLOCK);
const makeGetBlockHeader /*          */ = makeIx(InteractionTag.GET_BLOCK_HEADER);
const makeGetCollection /*           */ = makeIx(InteractionTag.GET_COLLECTION);
const makeGetNetworkParameters /*    */ = makeIx(InteractionTag.GET_NETWORK_PARAMETERS);
const makeSubscribeEvents /*         */ = makeIx(InteractionTag.SUBSCRIBE_EVENTS);
const makeGetNodeVerionInfo /*       */ = makeIx(InteractionTag.GET_NODE_VERSION_INFO);
const is = wat => ix => ix.tag === wat;
const isUnknown /*                 */ = is(InteractionTag.UNKNOWN);
const isScript /*                  */ = is(InteractionTag.SCRIPT);
const isTransaction /*             */ = is(InteractionTag.TRANSACTION);
const isGetTransactionStatus /*    */ = is(InteractionTag.GET_TRANSACTION_STATUS);
const isGetTransaction /*          */ = is(InteractionTag.GET_TRANSACTION);
const isGetAccount /*              */ = is(InteractionTag.GET_ACCOUNT);
const isGetEvents /*               */ = is(InteractionTag.GET_EVENTS);
const isPing /*                    */ = is(InteractionTag.PING);
const isGetBlock /*                */ = is(InteractionTag.GET_BLOCK);
const isGetBlockHeader /*          */ = is(InteractionTag.GET_BLOCK_HEADER);
const isGetCollection /*           */ = is(InteractionTag.GET_COLLECTION);
const isGetNetworkParameters /*    */ = is(InteractionTag.GET_NETWORK_PARAMETERS);
const isGetNodeVersionInfo /*      */ = is(InteractionTag.GET_NODE_VERSION_INFO);
const isSubscribeEvents /*         */ = is(InteractionTag.SUBSCRIBE_EVENTS);
const isOk /*  */ = ix => ix.status === InteractionStatus.OK;
const isBad /* */ = ix => ix.status === InteractionStatus.BAD;
const why /*   */ = ix => ix.reason;
const isAccount /*  */ = account => account.kind === InteractionResolverKind.ACCOUNT;
const isArgument /* */ = argument => argument.kind === InteractionResolverKind.ARGUMENT;
const hardMode = ix => {
  for (let key of Object.keys(ix)) {
    if (!KEYS.has(key)) throw new Error(`"${key}" is an invalid root level Interaction property.`);
  }
  return ix;
};
const recPipe = async function (ix) {
  let fns = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  try {
    ix = hardMode(await ix);
    if (isBad(ix)) throw new Error(`Interaction Error: ${ix.reason}`);
    if (!fns.length) return ix;
    const [hd, ...rest] = fns;
    const cur = await hd;
    if (isFn$3(cur)) return recPipe(cur(ix), rest);
    if (isNull(cur) || !cur) return recPipe(ix, rest);
    if (isInteraction(cur)) return recPipe(cur, rest);
    throw new Error("Invalid Interaction Composition");
  } catch (e) {
    throw e;
  }
};

/**
 * @description Async pipe function to compose interactions
 * @returns An interaction object
 */

/**
 * @description Async pipe function to compose interactions
 * @returns An interaction object
 */

function pipe() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }
  const [arg1, arg2] = args;
  if (isArray$1(arg1)) return d => pipe(d, arg1);
  const ix = arg1;
  const fns = arg2;
  return recPipe(ix, fns);
}
const identity$1 = function (v) {
  return v;
};
const get = (ix, key, fallback) => {
  return ix.assigns[key] == null ? fallback : ix.assigns[key];
};
const put = (key, value) => ix => {
  ix.assigns[key] = value;
  return Ok(ix);
};
const update = function (key) {
  let fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity$1;
  return ix => {
    ix.assigns[key] = fn(ix.assigns[key], ix);
    return Ok(ix);
  };
};
const destroy = key => ix => {
  delete ix.assigns[key];
  return Ok(ix);
};

var ixModule = /*#__PURE__*/Object.freeze({
  __proto__: null,
  initInteraction: initInteraction,
  interaction: interaction,
  isNumber: isNumber$1,
  isArray: isArray$1,
  isObj: isObj,
  isNull: isNull,
  isFn: isFn$3,
  isInteraction: isInteraction,
  Ok: Ok,
  Bad: Bad,
  initAccount: initAccount,
  prepAccount: prepAccount,
  makeArgument: makeArgument,
  makeUnknown: makeUnknown,
  makeScript: makeScript,
  makeTransaction: makeTransaction,
  makeGetTransactionStatus: makeGetTransactionStatus,
  makeGetTransaction: makeGetTransaction,
  makeGetAccount: makeGetAccount,
  makeGetEvents: makeGetEvents,
  makePing: makePing,
  makeGetBlock: makeGetBlock,
  makeGetBlockHeader: makeGetBlockHeader,
  makeGetCollection: makeGetCollection,
  makeGetNetworkParameters: makeGetNetworkParameters,
  makeSubscribeEvents: makeSubscribeEvents,
  makeGetNodeVerionInfo: makeGetNodeVerionInfo,
  isUnknown: isUnknown,
  isScript: isScript,
  isTransaction: isTransaction,
  isGetTransactionStatus: isGetTransactionStatus,
  isGetTransaction: isGetTransaction,
  isGetAccount: isGetAccount,
  isGetEvents: isGetEvents,
  isPing: isPing,
  isGetBlock: isGetBlock,
  isGetBlockHeader: isGetBlockHeader,
  isGetCollection: isGetCollection,
  isGetNetworkParameters: isGetNetworkParameters,
  isGetNodeVersionInfo: isGetNodeVersionInfo,
  isSubscribeEvents: isSubscribeEvents,
  isOk: isOk,
  isBad: isBad,
  why: why,
  isAccount: isAccount,
  isArgument: isArgument,
  pipe: pipe,
  get: get,
  put: put,
  update: update,
  destroy: destroy
});

function build() {
  let fns = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return pipe(initInteraction(), fns);
}

const DEFAULT_RESPONSE = {
  tag: null,
  transaction: null,
  transactionStatus: null,
  transactionId: null,
  encodedData: null,
  events: null,
  account: null,
  block: null,
  blockHeader: null,
  latestBlock: null,
  collection: null,
  networkParameters: null,
  streamConnection: null,
  heartbeat: null,
  nodeVersionInfo: null
};
const response = () => ({
  ...DEFAULT_RESPONSE
});

/**
 * @description - A builder function that returns the interaction to get the latest block
 * @param {boolean} [isSealed] - Whether or not the block should be sealed
 * @returns {Function} - An interaction object
 */
function getBlock() {
  let isSealed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  return pipe([makeGetBlock, ix => {
    ix.block.isSealed = isSealed;
    return Ok(ix);
  }]);
}

/**
 * @description - A builder function that returns the interaction to get an account by address
 * @param {string} addr - The address of the account to getq
 * @returns {Function} - An interaction object
 */
function getAccount(addr) {
  return pipe([makeGetAccount, ix => {
    ix.account.addr = sansPrefix(addr);
    return Ok(ix);
  }]);
}

/**
 * Pipes a generic stream of data into a granular stream of decoded data
 * The data is decoded per channel and emitted in order
 */
const decodeStream = (stream, decodeResponse, customDecoders) => {
  const newStream = new EventEmitter();
  let queue = taskQueue();

  // Data is separated by topic & the decoded data is emitted in order
  // All topics for a given message will be emitted synchronously before moving on to the next message
  // The streamReady promise ensures that the data is emitted in order and avoids race conditions when decoding
  stream.on("data", async data => {
    const topics = Object.keys(data).filter(key => data[key] != null && key !== "tag");
    let newDataPromise = Promise.all(topics.map(async channel => {
      const partialResponse = {
        [channel]: data[channel]
      };
      const message = await decodeResponse(partialResponse, customDecoders);
      return {
        channel,
        message
      };
    }));
    queue.push(async () => {
      // Emit the new data
      const newData = await newDataPromise;
      newData.forEach(_ref => {
        let {
          channel,
          message
        } = _ref;
        newStream.emit(channel, message);
      });
    });
  });

  // Relay events from the original stream
  // These events are delivered in order as well so that the stream will
  // not emit more data after it has announced a contradictory state
  function relayEvent(event) {
    stream.on(event, message => {
      queue.push(async () => {
        newStream.emit(event, message);
      });
    });
  }
  relayEvent("close");
  relayEvent("error");
  return {
    on(channel, callback) {
      newStream.on(channel, callback);
      return this;
    },
    off(channel, callback) {
      newStream.off(channel, callback);
      return this;
    },
    close: () => {
      stream.close();
    }
  };
};
function taskQueue() {
  let queue = [];
  let running = false;
  async function run() {
    if (running) return;
    running = true;
    while (queue.length > 0) {
      const task = queue.shift();
      await task?.();
    }
    running = false;
  }
  return {
    push: task => {
      queue.push(task);
      run();
    }
  };
}

const latestBlockDeprecationNotice = () => {
  log.deprecate({
    pkg: "@onflow/decode",
    subject: "Operating upon data of the latestBlock field of the response object",
    transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/decode/WARNINGS.md#0001-Deprecating-latestBlock-field"
  });
};
const decodeImplicit = async i => i;
const decodeVoid = async () => null;
const decodeType = async type => {
  return type.staticType;
};
const decodeOptional = async (optional, decoders, stack) => optional ? await recurseDecode(optional, decoders, stack) : null;
const decodeArray = async (array, decoders, stack) => await Promise.all(array.map(v => new Promise(async res => res(await recurseDecode(v, decoders, [...stack, v.type])))));
const decodeDictionary = async (dictionary, decoders, stack) => await dictionary.reduce(async (acc, v) => {
  acc = await acc;
  acc[await recurseDecode(v.key, decoders, [...stack, v.key])] = await recurseDecode(v.value, decoders, [...stack, v.key]);
  return acc;
}, Promise.resolve({}));
const decodeComposite = async (composite, decoders, stack) => {
  const decoded = await composite.fields.reduce(async (acc, v) => {
    acc = await acc;
    acc[v.name] = await recurseDecode(v.value, decoders, [...stack, v.name]);
    return acc;
  }, Promise.resolve({}));
  const decoder = composite.id && decoderLookup(decoders, composite.id);
  return decoder ? await decoder(decoded) : decoded;
};
const decodeInclusiveRange = async (range, decoders, stack) => {
  // Recursive decode for start, end, and step
  // We don't do all fields just in case there are future API changes
  // where fields added and are not Cadence values
  const keys = ["start", "end", "step"];
  const decoded = await Object.keys(range).reduce(async (acc, key) => {
    acc = await acc;
    if (keys.includes(key)) {
      acc[key] = await recurseDecode(range[key], decoders, [...stack, key]);
    }
    return acc;
  }, Promise.resolve({}));
  return decoded;
};
const defaultDecoders = {
  UInt: decodeImplicit,
  Int: decodeImplicit,
  UInt8: decodeImplicit,
  Int8: decodeImplicit,
  UInt16: decodeImplicit,
  Int16: decodeImplicit,
  UInt32: decodeImplicit,
  Int32: decodeImplicit,
  UInt64: decodeImplicit,
  Int64: decodeImplicit,
  UInt128: decodeImplicit,
  Int128: decodeImplicit,
  UInt256: decodeImplicit,
  Int256: decodeImplicit,
  Word8: decodeImplicit,
  Word16: decodeImplicit,
  Word32: decodeImplicit,
  Word64: decodeImplicit,
  Word128: decodeImplicit,
  Word256: decodeImplicit,
  UFix64: decodeImplicit,
  Fix64: decodeImplicit,
  String: decodeImplicit,
  Character: decodeImplicit,
  Bool: decodeImplicit,
  Address: decodeImplicit,
  Void: decodeVoid,
  Optional: decodeOptional,
  Reference: decodeImplicit,
  Array: decodeArray,
  Dictionary: decodeDictionary,
  Event: decodeComposite,
  Resource: decodeComposite,
  Struct: decodeComposite,
  Enum: decodeComposite,
  Type: decodeType,
  Path: decodeImplicit,
  Capability: decodeImplicit,
  InclusiveRange: decodeInclusiveRange
};
const decoderLookup = (decoders, lookup) => {
  const found = Object.keys(decoders).find(decoder => {
    if (/^\/.*\/$/.test(decoder)) {
      const reg = new RegExp(decoder.substring(1, decoder.length - 1));
      return reg.test(lookup);
    }
    return decoder === lookup;
  });
  return lookup && found && decoders[found];
};
const recurseDecode = async (decodeInstructions, decoders, stack) => {
  let decoder = decoderLookup(decoders, decodeInstructions.type);
  if (!decoder) throw new Error(`Undefined Decoder Error: ${decodeInstructions.type}@${stack.join(".")}`);
  return await decoder(decodeInstructions.value, decoders, stack);
};

/**
 * @description - Decodes a response from Flow into JSON
 * @param {*} decodeInstructions - The response object from Flow
 * @param {object} customDecoders - An object of custom decoders
 * @param {Array<*>} stack - The stack of the current decoding
 * @returns {Promise<*>} - The decoded response
 */
const decode$1 = async function (decodeInstructions) {
  let customDecoders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  let stack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  // Filter out all default decoders which are overridden by a custom decoder regex
  const filteredDecoders = Object.keys(defaultDecoders).filter(decoder => !Object.keys(customDecoders).find(customDecoder => new RegExp(customDecoder).test(decoder))).reduce((decoders, decoderKey) => {
    decoders[decoderKey] = defaultDecoders[decoderKey];
    return decoders;
  }, customDecoders);
  const decoders = {
    ...filteredDecoders,
    ...customDecoders
  };
  return recurseDecode(decodeInstructions, decoders, stack);
};
const decodeResponse = async function (response) {
  let customDecoders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (response.encodedData) {
    return decode$1(response.encodedData, customDecoders);
  } else if (response.transactionStatus) {
    return {
      ...response.transactionStatus,
      events: await Promise.all(response.transactionStatus.events.map(async function decodeEvents(e) {
        return {
          type: e.type,
          transactionId: e.transactionId,
          transactionIndex: e.transactionIndex,
          eventIndex: e.eventIndex,
          data: await decode$1(e.payload, customDecoders)
        };
      }))
    };
  } else if (response.transaction) {
    return response.transaction;
  } else if (response.events) {
    return await Promise.all(response.events.map(async function decodeEvents(e) {
      return {
        blockId: e.blockId,
        blockHeight: e.blockHeight,
        blockTimestamp: e.blockTimestamp,
        type: e.type,
        transactionId: e.transactionId,
        transactionIndex: e.transactionIndex,
        eventIndex: e.eventIndex,
        data: await decode$1(e.payload, customDecoders)
      };
    }));
  } else if (response.account) {
    return response.account;
  } else if (response.block) {
    return response.block;
  } else if (response.blockHeader) {
    return response.blockHeader;
  } else if (response.latestBlock) {
    latestBlockDeprecationNotice();
    return response.latestBlock;
  } else if (response.transactionId) {
    return response.transactionId;
  } else if (response.collection) {
    return response.collection;
  } else if (response.networkParameters) {
    const prefixRegex = /^flow-/;
    const rawChainId = response.networkParameters.chainId;
    let formattedChainId;
    if (rawChainId === "flow-emulator") {
      formattedChainId = "local";
    } else if (prefixRegex.test(rawChainId)) {
      formattedChainId = rawChainId.replace(prefixRegex, "");
    } else {
      formattedChainId = rawChainId;
    }
    return {
      chainId: formattedChainId
    };
  } else if (response.streamConnection) {
    return decodeStream(response.streamConnection, decodeResponse, customDecoders);
  } else if (response.heartbeat) {
    return response.heartbeat;
  } else if (response.nodeVersionInfo) {
    return response.nodeVersionInfo;
  }
  return null;
};

const isFn$2 = v => typeof v === "function";
const isString$1 = v => typeof v === "string";
const oldIdentifierPatternFn = () => /\b(0x\w+)\b/g;
function isOldIdentifierSyntax(cadence) {
  return oldIdentifierPatternFn().test(cadence);
}
const newIdentifierPatternFn = () => /import\s+"(\w+)"/g;
function isNewIdentifierSyntax(cadence) {
  return newIdentifierPatternFn().test(cadence);
}
function getContractIdentifierSyntaxMatches(cadence) {
  return cadence.matchAll(newIdentifierPatternFn());
}
async function resolveCadence(ix) {
  if (!isTransaction(ix) && !isScript(ix)) return ix;
  var cadence = get(ix, "ix.cadence");
  invariant$1(isFn$2(cadence) || isString$1(cadence), "Cadence needs to be a function or a string.");
  if (isFn$2(cadence)) cadence = await cadence({});
  invariant$1(isString$1(cadence), "Cadence needs to be a string at this point.");
  invariant$1(!isOldIdentifierSyntax(cadence) || !isNewIdentifierSyntax(cadence), "Both account identifier and contract identifier syntax not simultaneously supported.");
  if (isOldIdentifierSyntax(cadence)) {
    cadence = await config().where(/^0x/).then(d => Object.entries(d).reduce((cadence, _ref) => {
      let [key, value] = _ref;
      const regex = new RegExp("(\\b" + key + "\\b)", "g");
      return cadence.replace(regex, value);
    }, cadence));
  }
  if (isNewIdentifierSyntax(cadence)) {
    for (const [fullMatch, contractName] of getContractIdentifierSyntaxMatches(cadence)) {
      const address = await config().get(`system.contracts.${contractName}`);
      if (address) {
        cadence = cadence.replace(fullMatch, `import ${contractName} from ${withPrefix(address)}`);
      } else {
        logger.log({
          title: "Contract Placeholder not found",
          message: `Cannot find a value for contract placeholder ${contractName}. Please add to your flow.json or explicitly add it to the config 'contracts.*' namespace.`,
          level: logger.LEVELS.warn
        });
      }
    }
  }

  // We need to move this over in any case.
  ix.message.cadence = cadence;
  return ix;
}

const isFn$1 = v => typeof v === "function";
function cast(arg) {
  // prettier-ignore
  invariant$1(typeof arg.xform != null, `No type specified for argument: ${arg.value}`);
  if (isFn$1(arg.xform)) return arg.xform(arg.value);
  if (isFn$1(arg.xform.asArgument)) return arg.xform.asArgument(arg.value);

  // prettier-ignore
  invariant$1(false, `Invalid Argument`, arg);
}
async function handleArgResolution(arg) {
  let depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;
  invariant$1(depth > 0, `Argument Resolve Recursion Limit Exceeded for Arg: ${arg.tempId}`);
  if (isFn$1(arg.resolveArgument)) {
    const resolvedArg = await arg.resolveArgument();
    return handleArgResolution(resolvedArg, depth - 1);
  } else {
    return arg;
  }
}
async function resolveArguments(ix) {
  if (isTransaction(ix) || isScript(ix)) {
    for (let [id, arg] of Object.entries(ix.arguments)) {
      const res = await handleArgResolution(arg);
      ix.arguments[id].asArgument = cast(res);
    }
  }
  return ix;
}

const encodeTransactionPayload = tx => prependTransactionDomainTag(rlpEncode(preparePayload(tx)));
const encodeTransactionEnvelope = tx => prependTransactionDomainTag(rlpEncode(prepareEnvelope(tx)));
const encodeTxIdFromVoucher = voucher => sha3_256(rlpEncode(prepareVoucher(voucher)));
const rightPaddedHexBuffer = (value, pad) => Buffer.from(value.padEnd(pad * 2, "0"), "hex");
const leftPaddedHexBuffer = (value, pad) => Buffer.from(value.padStart(pad * 2, "0"), "hex");
const TRANSACTION_DOMAIN_TAG = rightPaddedHexBuffer(Buffer.from("FLOW-V0.0-transaction").toString("hex"), 32).toString("hex");
const prependTransactionDomainTag = tx => TRANSACTION_DOMAIN_TAG + tx;
const addressBuffer = addr => leftPaddedHexBuffer(addr, 8);
const blockBuffer = block => leftPaddedHexBuffer(block, 32);
const argumentToString = arg => Buffer.from(JSON.stringify(arg), "utf8");
const scriptBuffer = script => Buffer.from(script, "utf8");
const signatureBuffer = signature => Buffer.from(signature, "hex");
const rlpEncode = v => {
  return encode(v).toString("hex");
};
const sha3_256 = msg => {
  const sha = new SHA3(256);
  sha.update(Buffer.from(msg, "hex"));
  return sha.digest().toString("hex");
};
const preparePayload = tx => {
  validatePayload(tx);
  return [scriptBuffer(tx.cadence || ""), tx.arguments.map(argumentToString), blockBuffer(tx.refBlock || ""), tx.computeLimit, addressBuffer(sansPrefix(tx.proposalKey.address || "")), tx.proposalKey.keyId, tx.proposalKey.sequenceNum, addressBuffer(sansPrefix(tx.payer)), tx.authorizers.map(authorizer => addressBuffer(sansPrefix(authorizer)))];
};
const prepareEnvelope = tx => {
  validateEnvelope(tx);
  return [preparePayload(tx), preparePayloadSignatures(tx)];
};
const preparePayloadSignatures = tx => {
  const signers = collectSigners(tx);
  return tx.payloadSigs?.map(sig => {
    return {
      signerIndex: signers.get(sig.address) || "",
      keyId: sig.keyId,
      sig: sig.sig
    };
  }).sort((a, b) => {
    if (a.signerIndex > b.signerIndex) return 1;
    if (a.signerIndex < b.signerIndex) return -1;
    if (a.keyId > b.keyId) return 1;
    if (a.keyId < b.keyId) return -1;
    return 0;
  }).map(sig => {
    return [sig.signerIndex, sig.keyId, signatureBuffer(sig.sig)];
  });
};
const collectSigners = tx => {
  const signers = new Map();
  let i = 0;
  const addSigner = addr => {
    if (!signers.has(addr)) {
      signers.set(addr, i);
      i++;
    }
  };
  if (tx.proposalKey.address) {
    addSigner(tx.proposalKey.address);
  }
  addSigner(tx.payer);
  tx.authorizers.forEach(addSigner);
  return signers;
};
const prepareVoucher = voucher => {
  validateVoucher(voucher);
  const signers = collectSigners(voucher);
  const prepareSigs = sigs => {
    return sigs.map(_ref => {
      let {
        address,
        keyId,
        sig
      } = _ref;
      return {
        signerIndex: signers.get(address) || "",
        keyId,
        sig
      };
    }).sort((a, b) => {
      if (a.signerIndex > b.signerIndex) return 1;
      if (a.signerIndex < b.signerIndex) return -1;
      if (a.keyId > b.keyId) return 1;
      if (a.keyId < b.keyId) return -1;
      return 0;
    }).map(sig => {
      return [sig.signerIndex, sig.keyId, signatureBuffer(sig.sig)];
    });
  };
  return [[scriptBuffer(voucher.cadence), voucher.arguments.map(argumentToString), blockBuffer(voucher.refBlock), voucher.computeLimit, addressBuffer(sansPrefix(voucher.proposalKey.address)), voucher.proposalKey.keyId, voucher.proposalKey.sequenceNum, addressBuffer(sansPrefix(voucher.payer)), voucher.authorizers.map(authorizer => addressBuffer(sansPrefix(authorizer)))], prepareSigs(voucher.payloadSigs), prepareSigs(voucher.envelopeSigs)];
};
const validatePayload = tx => {
  payloadFields.forEach(field => checkField(tx, field));
  proposalKeyFields.forEach(field => checkField(tx.proposalKey, field, "proposalKey"));
};
const validateEnvelope = tx => {
  payloadSigsFields.forEach(field => checkField(tx, field));
  tx.payloadSigs?.forEach((sig, index) => {
    payloadSigFields.forEach(field => checkField(sig, field, "payloadSigs", index));
  });
};
const validateVoucher = voucher => {
  payloadFields.forEach(field => checkField(voucher, field));
  proposalKeyFields.forEach(field => checkField(voucher.proposalKey, field, "proposalKey"));
  payloadSigsFields.forEach(field => checkField(voucher, field));
  voucher.payloadSigs.forEach((sig, index) => {
    payloadSigFields.forEach(field => checkField(sig, field, "payloadSigs", index));
  });
  envelopeSigsFields.forEach(field => checkField(voucher, field));
  voucher.envelopeSigs.forEach((sig, index) => {
    envelopeSigFields.forEach(field => checkField(sig, field, "envelopeSigs", index));
  });
};
const isNumber = v => typeof v === "number";
const isString = v => typeof v === "string";
const isObject = v => v !== null && typeof v === "object";
const isArray = v => isObject(v) && v instanceof Array;
const payloadFields = [{
  name: "cadence",
  check: isString
}, {
  name: "arguments",
  check: isArray
}, {
  name: "refBlock",
  check: isString,
  defaultVal: "0"
}, {
  name: "computeLimit",
  check: isNumber
}, {
  name: "proposalKey",
  check: isObject
}, {
  name: "payer",
  check: isString
}, {
  name: "authorizers",
  check: isArray
}];
const proposalKeyFields = [{
  name: "address",
  check: isString
}, {
  name: "keyId",
  check: isNumber
}, {
  name: "sequenceNum",
  check: isNumber
}];
const payloadSigsFields = [{
  name: "payloadSigs",
  check: isArray
}];
const payloadSigFields = [{
  name: "address",
  check: isString
}, {
  name: "keyId",
  check: isNumber
}, {
  name: "sig",
  check: isString
}];
const envelopeSigsFields = [{
  name: "envelopeSigs",
  check: isArray
}];
const envelopeSigFields = [{
  name: "address",
  check: isString
}, {
  name: "keyId",
  check: isNumber
}, {
  name: "sig",
  check: isString
}];
const checkField = (obj, field, base, index) => {
  const {
    name,
    check,
    defaultVal
  } = field;
  if (obj[name] == null && defaultVal != null) obj[name] = defaultVal;
  if (obj[name] == null) throw missingFieldError(name, base, index);
  if (!check(obj[name])) throw invalidFieldError(name, base, index);
};
const printFieldName = (field, base, index) => {
  if (!!base) return index == null ? `${base}.${field}` : `${base}.${index}.${field}`;
  return field;
};
const missingFieldError = (field, base, index) => new Error(`Missing field ${printFieldName(field, base, index)}`);
const invalidFieldError = (field, base, index) => new Error(`Invalid field ${printFieldName(field, base, index)}`);

function findInsideSigners(ix) {
  // Inside Signers Are: (authorizers + proposer) - payer
  let inside = new Set(ix.authorizations);
  if (ix.proposer) {
    inside.add(ix.proposer);
  }
  if (Array.isArray(ix.payer)) {
    ix.payer.forEach(p => inside.delete(p));
  } else {
    inside.delete(ix.payer);
  }
  return Array.from(inside);
}
function findOutsideSigners(ix) {
  // Outside Signers Are: (payer)
  let outside = new Set(Array.isArray(ix.payer) ? ix.payer : [ix.payer]);
  return Array.from(outside);
}
const createSignableVoucher = ix => {
  const buildAuthorizers = () => {
    const authorizations = ix.authorizations.map(cid => withPrefix(ix.accounts[cid].addr)).reduce((prev, current) => {
      return prev.find(item => item === current) ? prev : [...prev, current];
    }, []);
    return authorizations?.[0] ? authorizations : [];
  };
  const buildInsideSigners = () => findInsideSigners(ix).map(id => ({
    address: withPrefix(ix.accounts[id].addr),
    keyId: ix.accounts[id].keyId,
    sig: ix.accounts[id].signature
  }));
  const buildOutsideSigners = () => findOutsideSigners(ix).map(id => ({
    address: withPrefix(ix.accounts[id].addr),
    keyId: ix.accounts[id].keyId,
    sig: ix.accounts[id].signature
  }));
  const proposalKey = ix.proposer ? {
    address: withPrefix(ix.accounts[ix.proposer].addr),
    keyId: ix.accounts[ix.proposer].keyId,
    sequenceNum: ix.accounts[ix.proposer].sequenceNum
  } : {};
  return {
    cadence: ix.message.cadence,
    refBlock: ix.message.refBlock || null,
    computeLimit: ix.message.computeLimit,
    arguments: ix.message.arguments.map(id => ix.arguments[id].asArgument),
    proposalKey,
    payer: withPrefix(ix.accounts[Array.isArray(ix.payer) ? ix.payer[0] : ix.payer].addr),
    authorizers: buildAuthorizers(),
    payloadSigs: buildInsideSigners(),
    envelopeSigs: buildOutsideSigners()
  };
};
const voucherToTxId = voucher => {
  return encodeTxIdFromVoucher(voucher);
};

const MAX_DEPTH_LIMIT = 5;
const idof$1 = acct => `${withPrefix(acct.addr)}-${acct.keyId}`;
const isFn = v => v && (Object.prototype.toString.call(v) === "[object Function]" || "function" === typeof v || v instanceof Function);
const genAccountId = function () {
  for (var _len = arguments.length, ids = new Array(_len), _key = 0; _key < _len; _key++) {
    ids[_key] = arguments[_key];
  }
  return ids.join("-");
};
var ROLES = /*#__PURE__*/function (ROLES) {
  ROLES["PAYER"] = "payer";
  ROLES["PROPOSER"] = "proposer";
  ROLES["AUTHORIZATIONS"] = "authorizations";
  return ROLES;
}(ROLES || {});
function debug$1() {
  const SPACE = " ";
  const SPACE_COUNT_PER_INDENT = 4;
  const DEBUG_MESSAGE = [];
  return [function () {
    let msg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    let indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    DEBUG_MESSAGE.push(Array(indent * SPACE_COUNT_PER_INDENT).fill(SPACE).join("-") + msg);
  }, function () {
    return DEBUG_MESSAGE.reduce((prev, curr) => prev + "\n" + curr);
  }];
}
function recurseFlatMap(el) {
  let depthLimit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;
  if (depthLimit <= 0) return el;
  if (!Array.isArray(el)) return el;
  return recurseFlatMap(el.flatMap(e => e), depthLimit - 1);
}
function buildPreSignable(acct, ix) {
  try {
    return {
      f_type: "PreSignable",
      f_vsn: "1.0.1",
      roles: acct.role,
      cadence: ix.message.cadence,
      args: ix.message.arguments.map(d => ix.arguments[d].asArgument),
      data: {},
      interaction: ix,
      voucher: createSignableVoucher(ix)
    };
  } catch (error) {
    console.error("buildPreSignable", error);
    throw error;
  }
}
async function removeUnusedIxAccounts(ix, opts) {
  const payerTempIds = Array.isArray(ix.payer) ? ix.payer : [ix.payer];
  const authorizersTempIds = Array.isArray(ix.authorizations) ? ix.authorizations : [ix.authorizations];
  const proposerTempIds = ix.proposer === null ? [] : Array.isArray(ix.proposer) ? ix.proposer : [ix.proposer];
  const ixAccountKeys = Object.keys(ix.accounts);
  const uniqueTempIds = [...new Set(payerTempIds.concat(authorizersTempIds, proposerTempIds))];
  for (const ixAccountKey of ixAccountKeys) {
    if (!uniqueTempIds.find(id => id === ixAccountKey)) {
      delete ix.accounts[ixAccountKey];
    }
  }
}
function addAccountToIx(ix, newAccount) {
  if (typeof newAccount.addr === "string" && (typeof newAccount.keyId === "number" || typeof newAccount.keyId === "string")) {
    newAccount.tempId = idof$1(newAccount);
  } else {
    newAccount.tempId = newAccount.tempId || v4();
  }
  const existingAccount = ix.accounts[newAccount.tempId] || newAccount;
  if (!ix.accounts[newAccount.tempId]) {
    ix.accounts[newAccount.tempId] = newAccount;
  }
  ix.accounts[newAccount.tempId].role.proposer = existingAccount.role.proposer || newAccount.role.proposer;
  ix.accounts[newAccount.tempId].role.payer = existingAccount.role.payer || newAccount.role.payer;
  ix.accounts[newAccount.tempId].role.authorizer = existingAccount.role.authorizer || newAccount.role.authorizer;
  return ix.accounts[newAccount.tempId];
}
function uniqueAccountsFlatMap(accounts) {
  const flatMapped = recurseFlatMap(accounts);
  const seen = new Set();
  const uniqueAccountsFlatMapped = flatMapped.map(account => {
    const accountId = genAccountId(account.tempId, account.role.payer, account.role.proposer, account.role.authorizer, account.role.param);
    if (seen.has(accountId)) return null;
    seen.add(accountId);
    return account;
  }).filter(e => e !== null);
  return uniqueAccountsFlatMapped;
}
async function recurseResolveAccount(ix, currentAccountTempId) {
  let depthLimit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : MAX_DEPTH_LIMIT;
  let {
    debugLogger
  } = arguments.length > 3 ? arguments[3] : undefined;
  if (depthLimit <= 0) {
    throw new Error(`recurseResolveAccount Error: Depth limit (${MAX_DEPTH_LIMIT}) reached. Ensure your authorization functions resolve to an account after ${MAX_DEPTH_LIMIT} resolves.`);
  }
  let account = ix.accounts[currentAccountTempId];
  if (!account) return null;
  debugLogger(`account: ${account.tempId}`, Math.max(MAX_DEPTH_LIMIT - depthLimit, 0));
  if (account?.resolve) {
    if (isFn(account?.resolve)) {
      debugLogger(`account: ${account.tempId} -- cache MISS`, Math.max(MAX_DEPTH_LIMIT - depthLimit, 0));
      const {
        resolve,
        ...accountWithoutResolve
      } = account;
      let resolvedAccounts = await resolve(accountWithoutResolve, buildPreSignable(accountWithoutResolve, ix));
      resolvedAccounts = Array.isArray(resolvedAccounts) ? resolvedAccounts : [resolvedAccounts];
      let flatResolvedAccounts = recurseFlatMap(resolvedAccounts);
      flatResolvedAccounts = flatResolvedAccounts.map(flatResolvedAccount => addAccountToIx(ix, flatResolvedAccount));
      account.resolve = flatResolvedAccounts.map(flatResolvedAccount => flatResolvedAccount.tempId);
      account = addAccountToIx(ix, account);
      const recursedAccounts = await Promise.all(flatResolvedAccounts.map(async resolvedAccount => {
        return await recurseResolveAccount(ix, resolvedAccount.tempId, depthLimit - 1, {
          debugLogger
        });
      }));
      return recursedAccounts ? recurseFlatMap(recursedAccounts) : account.tempId;
    } else {
      debugLogger(`account: ${account.tempId} -- cache HIT`, Math.max(MAX_DEPTH_LIMIT - depthLimit, 0));
      return account.resolve;
    }
  }
  return account.tempId;
}
const getAccountTempIDs = rawTempIds => {
  if (rawTempIds === null) {
    return [];
  }
  return Array.isArray(rawTempIds) ? rawTempIds : [rawTempIds];
};
async function resolveAccountType(ix, type, _ref) {
  let {
    debugLogger
  } = _ref;
  invariant$1(ix && typeof ix === "object", "resolveAccountType Error: ix not defined");
  invariant$1(type === ROLES.PAYER || type === ROLES.PROPOSER || type === ROLES.AUTHORIZATIONS, "resolveAccountType Error: type must be 'payer', 'proposer' or 'authorizations'");
  let accountTempIDs = getAccountTempIDs(ix[type]);
  let allResolvedAccounts = [];
  for (let accountId of accountTempIDs) {
    let account = ix.accounts[accountId];
    invariant$1(Boolean(account), `resolveAccountType Error: account not found`);
    let resolvedAccountTempIds = await recurseResolveAccount(ix, accountId, MAX_DEPTH_LIMIT, {
      debugLogger
    });
    resolvedAccountTempIds = Array.isArray(resolvedAccountTempIds) ? resolvedAccountTempIds : [resolvedAccountTempIds];
    let resolvedAccounts = resolvedAccountTempIds.map(resolvedAccountTempId => ix.accounts[resolvedAccountTempId]);
    let flatResolvedAccounts = uniqueAccountsFlatMap(resolvedAccounts);
    allResolvedAccounts = allResolvedAccounts.concat(flatResolvedAccounts);
  }
  invariant$1(allResolvedAccounts.length > 0 || type === ROLES.AUTHORIZATIONS, `resolveAccountType Error: no ${type} accounts were found`);
  if (type === ROLES.PAYER) {
    allResolvedAccounts = allResolvedAccounts.filter(acct => acct.role.payer === true);
  }
  if (type === ROLES.PROPOSER) {
    allResolvedAccounts = allResolvedAccounts.filter(acct => acct.role.proposer === true);
  }
  if (type === ROLES.AUTHORIZATIONS) {
    allResolvedAccounts = allResolvedAccounts.filter(acct => acct.role.authorizer === true);
  }
  ix[type] = Array.isArray(ix[type]) ? [...new Set(allResolvedAccounts.map(acct => acct.tempId))] : allResolvedAccounts[0].tempId;

  // Ensure all payers are of the same account
  if (type === ROLES.PAYER) {
    let address;
    for (const payerTempID of ix[ROLES.PAYER]) {
      let pAcct = ix.accounts[payerTempID];
      if (!address) address = pAcct.addr;else if (address !== pAcct.addr) {
        throw new Error("resolveAccountType Error: payers from different accounts detected");
      }
    }
  }
}
async function resolveAccounts(ix) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (isTransaction(ix)) {
    if (!Array.isArray(ix.payer)) {
      log.deprecate({
        pkg: "FCL",
        subject: '"ix.payer" must be an array. Support for ix.payer as a singular',
        message: "See changelog for more info."
      });
    }
    let [debugLogger, getDebugMessage] = debug$1();
    try {
      await resolveAccountType(ix, ROLES.PROPOSER, {
        debugLogger
      });
      await resolveAccountType(ix, ROLES.AUTHORIZATIONS, {
        debugLogger
      });
      await resolveAccountType(ix, ROLES.PAYER, {
        debugLogger
      });
      await removeUnusedIxAccounts(ix, {
        debugLogger
      });
      if (opts.enableDebug) {
        console.debug(getDebugMessage());
      }
    } catch (error) {
      console.error("=== SAD PANDA ===\n\n", error, "\n\n=== SAD PANDA ===");
      throw error;
    }
  }
  return ix;
}

async function resolveSignatures(ix) {
  if (isTransaction(ix)) {
    try {
      let insideSigners = findInsideSigners(ix);
      const insidePayload = encodeTransactionPayload(prepForEncoding(ix));

      // Promise.all could potentially break the flow if there are multiple inside signers trying to resolve at the same time
      // causing multiple triggers of authz function that tries to render multiple auth iiframes/tabs/extensions
      // as an alternative, use this:
      // for(const insideSigner of insideSigners) {
      //   await fetchSignature(ix, insidePayload)(insideSigner);
      // }
      await Promise.all(insideSigners.map(fetchSignature(ix, insidePayload)));
      let outsideSigners = findOutsideSigners(ix);
      const outsidePayload = encodeTransactionEnvelope({
        ...prepForEncoding(ix),
        payloadSigs: insideSigners.map(id => ({
          address: ix.accounts[id].addr || "",
          keyId: ix.accounts[id].keyId || 0,
          sig: ix.accounts[id].signature || ""
        }))
      });

      // Promise.all could potentially break the flow if there are multiple outside signers trying to resolve at the same time
      // causing multiple triggers of authz function that tries to render multiple auth iframes/tabs/extensions
      // as an alternative, use this:
      // for(const outsideSigner of outsideSigners) {
      //   await fetchSignature(ix, outsidePayload)(outsideSigner);
      // }
      await Promise.all(outsideSigners.map(fetchSignature(ix, outsidePayload)));
    } catch (error) {
      console.error("Signatures", error, {
        ix
      });
      throw error;
    }
  }
  return ix;
}
function fetchSignature(ix, payload) {
  return async function innerFetchSignature(id) {
    const acct = ix.accounts[id];
    if (acct.signature != null && acct.signature !== undefined) return;
    const {
      signature
    } = await acct.signingFunction(buildSignable(acct, payload, ix));
    ix.accounts[id].signature = signature;
  };
}
function buildSignable(acct, message, ix) {
  try {
    return {
      f_type: "Signable",
      f_vsn: "1.0.1",
      message,
      addr: sansPrefix(acct.addr),
      keyId: acct.keyId,
      roles: acct.role,
      cadence: ix.message.cadence,
      args: ix.message.arguments.map(d => ix.arguments[d].asArgument),
      data: {},
      interaction: ix,
      voucher: createSignableVoucher(ix)
    };
  } catch (error) {
    console.error("buildSignable", error);
    throw error;
  }
}
function prepForEncoding(ix) {
  const payerAddress = sansPrefix((Array.isArray(ix.payer) ? ix.accounts[ix.payer[0]] : ix.accounts[ix.payer]).addr || "");
  const proposalKey = ix.proposer ? {
    address: sansPrefix(ix.accounts[ix.proposer].addr) || "",
    keyId: ix.accounts[ix.proposer].keyId || 0,
    sequenceNum: ix.accounts[ix.proposer].sequenceNum || 0
  } : {};
  return {
    cadence: ix.message.cadence,
    refBlock: ix.message.refBlock,
    computeLimit: ix.message.computeLimit,
    arguments: ix.message.arguments.map(id => ix.arguments[id].asArgument),
    proposalKey,
    payer: payerAddress,
    authorizers: ix.authorizations.map(cid => sansPrefix(ix.accounts[cid].addr) || "").reduce((prev, current) => {
      return prev.find(item => item === current) ? prev : [...prev, current];
    }, [])
  };
}

async function resolveValidators(ix) {
  const validators = get(ix, "ix.validators", []);
  return pipe(ix, validators.map(cb => ix => cb(ix, {
    Ok,
    Bad
  })));
}

async function resolveFinalNormalization(ix) {
  for (let key of Object.keys(ix.accounts)) {
    ix.accounts[key].addr = sansPrefix(ix.accounts[key].addr);
  }
  return ix;
}

async function resolveVoucherIntercept(ix) {
  const fn = get(ix, "ix.voucher-intercept");
  if (isFn$3(fn)) {
    await fn(createSignableVoucher(ix));
  }
  return ix;
}

const DEFAULT_COMPUTE_LIMIT = 100;
async function resolveComputeLimit(ix) {
  if (isTransaction(ix)) {
    ix.message.computeLimit = ix.message.computeLimit || (await config.get("fcl.limit"));
    if (!ix.message.computeLimit) {
      logger.log.deprecate({
        pkg: "FCL/SDK",
        subject: "The built-in default compute limit (DEFAULT_COMPUTE_LIMIT=10)",
        transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0009-deprecate-default-compute-limit"
      });
      ix.message.computeLimit = DEFAULT_COMPUTE_LIMIT;
    }
  }
  return ix;
}

const noop = v => v;
const debug = function (key) {
  let fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;
  return async ix => {
    const accts = ix => ["\nAccounts:", {
      proposer: ix.proposer,
      authorizations: ix.authorizations,
      payer: ix.payer
    }, "\n\nDetails:", ix.accounts].filter(Boolean);
    const log = function () {
      for (var _len = arguments.length, msg = new Array(_len), _key = 0; _key < _len; _key++) {
        msg[_key] = arguments[_key];
      }
      console.log(`debug[${key}] ---\n`, ...msg, "\n\n\n---");
    };
    if (await config.get(`debug.${key}`)) await fn(ix, log, accts);
    return ix;
  };
};
const resolve = pipe([resolveCadence, debug("cadence", (ix, log) => log(ix.message.cadence)), resolveComputeLimit, debug("compute limit", (ix, log) => log(ix.message.computeLimit)), resolveArguments, debug("arguments", (ix, log) => log(ix.message.arguments, ix.message)), resolveAccounts, debug("accounts", (ix, log, accts) => log(...accts(ix))), /* special */execFetchRef, /* special */execFetchSequenceNumber, resolveSignatures, debug("signatures", (ix, log, accts) => log(...accts(ix))), resolveFinalNormalization, resolveValidators, resolveVoucherIntercept, debug("resolved", (ix, log) => log(ix))]);
async function execFetchRef(ix) {
  if (isTransaction(ix) && ix.message.refBlock == null) {
    const node = await config().get("accessNode.api");
    const sendFn = await config.first(["sdk.transport", "sdk.send"], send$1);
    invariant$1(sendFn, `Required value for sdk.transport is not defined in config. See: ${"https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21"}`);
    ix.message.refBlock = (await sendFn(build([getBlock()]), {
      config,
      response,
      Buffer,
      ix: ixModule
    }, {
      node
    }).then(decodeResponse)).id;
  }
  return ix;
}
async function execFetchSequenceNumber(ix) {
  if (isTransaction(ix)) {
    var acct = Object.values(ix.accounts).find(a => a.role.proposer);
    invariant$1(acct, `Transactions require a proposer`);
    if (acct.sequenceNum == null) {
      const node = await config().get("accessNode.api");
      const sendFn = await config.first(["sdk.transport", "sdk.send"], send$1);
      invariant$1(sendFn, `Required value for sdk.transport is not defined in config. See: ${"https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21"}`);
      ix.accounts[acct.tempId].sequenceNum = await sendFn(await build([getAccount(acct.addr)]), {
        config,
        response,
        Buffer,
        ix: ixModule
      }, {
        node
      }).then(decodeResponse).then(acct => acct.keys).then(keys => keys.find(key => key.index === acct.keyId)).then(key => key.sequenceNumber);
    }
  }
  return ix;
}

function invariant() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  if (args.length > 1) {
    const [predicate, message] = args;
    return invariant((ix, _ref) => {
      let {
        Ok,
        Bad
      } = _ref;
      return predicate ? Ok(ix) : Bad(ix, message);
    });
  }
  const [fn] = args;
  return ix => fn(ix, {
    Ok,
    Bad
  });
}

/**
 * @description - Sends arbitrary scripts, transactions, and requests to Flow
 * @param {Array.<Function>} args - An array of functions that take interaction and return interaction
 * @param {object} opts - Optional parameters
 * @returns {Promise<*>} - A promise that resolves to a response
 */
const send = async function () {
  let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const sendFn = await config.first(["sdk.transport", "sdk.send"], opts.send || send$1);
  invariant(sendFn, `Required value for sdk.transport is not defined in config. See: ${"https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21"}`);
  const resolveFn = await config.first(["sdk.resolve"], opts.resolve || resolve);
  opts.node = opts.node || (await config().get("accessNode.api"));
  if (Array.isArray(args)) args = pipe(initInteraction(), args);
  return sendFn(await resolveFn(args), {
    config,
    response,
    ix: ixModule,
    Buffer
  }, opts);
};

async function decode(response) {
  const decodersFromConfig = await config().where(/^decoder\./);
  const decoders = Object.entries(decodersFromConfig).map(_ref => {
    let [pattern, xform] = _ref;
    pattern = `/${pattern.replace(/^decoder\./, "")}$/`;
    return [pattern, xform];
  });
  return decodeResponse(response, Object.fromEntries(decoders));
}

const findPayloadSigners = voucher => {
  // Payload Signers Are: (authorizers + proposer) - payer
  let payload = new Set(voucher.authorizers);
  payload.add(voucher.proposalKey.address);
  payload.delete(voucher.payer);
  return Array.from(payload).map(withPrefix);
};
const findEnvelopeSigners = voucher => {
  // Envelope Signers Are: (payer)
  let envelope = new Set([voucher.payer]);
  return Array.from(envelope).map(withPrefix);
};
class UnableToDetermineMessageEncodingTypeForSignerAddress extends Error {
  constructor(signerAddress) {
    const msg = `
        Encode Message From Signable Error: Unable to determine message encoding for signer addresss: ${signerAddress}. 
        Please ensure the address: ${signerAddress} is intended to sign the given transaction as specified by the transaction signable.
      `.trim();
    super(msg);
    this.name = "Unable To Determine Message Encoding For Signer Addresss";
  }
}
const encodeMessageFromSignable = (signable, signerAddress) => {
  let payloadSigners = findPayloadSigners(signable.voucher);
  let envelopeSigners = findEnvelopeSigners(signable.voucher);
  const isPayloadSigner = payloadSigners.includes(withPrefix(signerAddress));
  const isEnvelopeSigner = envelopeSigners.includes(withPrefix(signerAddress));
  if (!isPayloadSigner && !isEnvelopeSigner) {
    throw new UnableToDetermineMessageEncodingTypeForSignerAddress(signerAddress);
  }
  const message = {
    cadence: signable.voucher.cadence,
    refBlock: signable.voucher.refBlock,
    computeLimit: signable.voucher.computeLimit,
    arguments: signable.voucher.arguments,
    proposalKey: {
      ...signable.voucher.proposalKey,
      address: sansPrefix(signable.voucher.proposalKey.address)
    },
    payer: sansPrefix(signable.voucher.payer),
    authorizers: signable.voucher.authorizers.map(sansPrefix),
    payloadSigs: signable.voucher.payloadSigs.map(ps => ({
      ...ps,
      address: sansPrefix(ps.address)
    }))
  };
  return isPayloadSigner ? encodeTransactionPayload(message) : encodeTransactionEnvelope(message);
};

function validator(cb) {
  return update("ix.validators", validators => Array.isArray(validators) ? validators.push(cb) : [cb]);
}

/**
 * @description - A builder function that returns a partial interaction to a block at a specific height
 * @param {number} height - The height of the block to get
 * @returns {Function} - A partial interaction object
 */
function atBlockHeight(height) {
  return pipe([ix => {
    ix.block.height = height;
    return ix;
  }, validator(ix => {
    if (typeof ix.block.isSealed === "boolean") throw new Error("Unable to specify both block height and isSealed.");
    if (ix.block.id) throw new Error("Unable to specify both block height and block id.");
    return ix;
  })]);
}

function atBlockId(id) {
  return pipe([ix => {
    ix.block.id = id;
    return Ok(ix);
  }, validator((ix, _ref) => {
    let {
      Ok,
      Bad
    } = _ref;
    if (isGetAccount(ix)) return Bad(ix, "Unable to specify a block id with a Get Account interaction.");
    if (typeof ix.block.isSealed === "boolean") return Bad(ix, "Unable to specify both block id and isSealed.");
    if (ix.block.height) return Bad(ix, "Unable to specify both block id and block height.");
    return Ok(ix);
  })]);
}

/**
 * @typedef {import("@onflow/typedefs").Account} Account
 */

/**
 * @description  Returns the details of an account from their public address
 * @param {string} address - Address of the account
 * @param {object} [queryOptions] - Query parameters
 * @param {number} [queryOptions.height] - Block height to query
 * @param {string} [queryOptions.id] - Block ID to query
 * @param {object} [opts] - Optional parameters
 * @returns {Promise<Account>} - A promise that resolves to an account response
 */
function account(address) {
  let {
    height,
    id
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  let opts = arguments.length > 2 ? arguments[2] : undefined;
  invariant$1(!(id && height), `Method: account -- Cannot pass "id" and "height" simultaneously`);

  // Get account by ID
  if (id) return send([getAccount(address), atBlockId(id)], opts).then(decodeResponse);

  // Get account by height
  if (height) return send([getAccount(address), atBlockHeight(height)], opts).then(decodeResponse);
  return send([getAccount(address)], opts).then(decodeResponse);
}

/**
 * @typedef {import("@onflow/typedefs").Block} Block
 */

/**
 * @description Returns the latest block (optionally sealed or not), by id, or by height
 * @param {object} [queryOptions] - Query parameters
 * @param {boolean} [queryOptions.sealed] - Whether to query for a sealed block
 * @param {number} [queryOptions.height] - Block height to query
 * @param {string} [queryOptions.id] - Block ID to query
 * @param {object} [opts] - Optional parameters
 * @returns {Promise<Block>} - A promise that resolves to a block response
 */
function block() {
  let {
    sealed = false,
    id,
    height
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  invariant$1(!(sealed && id || sealed && height), `Method: block -- Cannot pass "sealed" with "id" or "height"`);
  invariant$1(!(id && height), `Method: block -- Cannot pass "id" and "height" simultaneously`);

  // Get block by ID
  if (id) return send([getBlock(), atBlockId(id)], opts).then(decodeResponse);

  // Get block by height
  if (height) return send([getBlock(), atBlockHeight(height)], opts).then(decodeResponse);

  // Get latest block
  return send([getBlock(sealed)], opts).then(decodeResponse);
}

/**
 * A builder function for the Get Node Version Info interaction
 */
function getNodeVersionInfo() {
  return pipe([makeGetNodeVerionInfo, ix => {
    return Ok(ix);
  }]);
}

/**
 * @description Returns the version information from to connected node
 * @returns A promise that resolves to a block response
 */
async function nodeVersionInfo() {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return send([getNodeVersionInfo()], opts).then(decodeResponse);
}

function authorizations() {
  let ax = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return pipe(ax.map(authz => {
    return prepAccount(authz, {
      role: TransactionRole.AUTHORIZER
    });
  }));
}
function authorization(addr, signingFunction, keyId, sequenceNum) {
  return {
    addr,
    signingFunction,
    keyId,
    sequenceNum
  };
}

function getEvents(eventType, start, end) {
  if (typeof start !== "undefined" || typeof end !== "undefined") {
    logger.log.deprecate({
      pkg: "FCL/SDK",
      subject: "Passing a start and end into getEvents",
      transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0005-deprecate-start-end-get-events-builder"
    });
  }
  return pipe([makeGetEvents, ix => {
    ix.events.eventType = eventType;
    ix.events.start = start;
    ix.events.end = end;
    return Ok(ix);
  }]);
}

/**
 * @description - A builder function that returns all instances of a particular event (by name) within a height range
 * NOTE:
 * - The block range provided must be from the current spork.
 * - The block range provided must be 250 blocks or lower per request.
 * @param {string} eventName - The name of the event to get
 * @param {number} fromBlockHeight - The height of the block to start looking for events (inclusive)
 * @param {number} toBlockHeight - The height of the block to stop looking for events (inclusive)
 * @returns {Function} - An interaction object
 */
function getEventsAtBlockHeightRange(eventName, fromBlockHeight, toBlockHeight) {
  return pipe([makeGetEvents, ix => {
    ix.events.eventType = eventName;
    ix.events.start = fromBlockHeight;
    ix.events.end = toBlockHeight;
    return Ok(ix);
  }]);
}

/**
 * @description - A builder function that returns all instances of a particular event (by name) within a set of blocks, specified by block ids
 * NOTE:
 * - The block range provided must be from the current spork.
 * @param {string} eventName - The name of the event to get
 * @param {number[]} blockIds - The ids of the blocks to look for events
 * @returns {Function} - An interaction object
 */
function getEventsAtBlockIds(eventName) {
  let blockIds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  return pipe([makeGetEvents, ix => {
    ix.events.eventType = eventName;
    ix.events.blockIds = blockIds;
    return Ok(ix);
  }]);
}

/**
 * @description - A builder function that returns the interaction to get a block header
 * @param {boolean} [isSealed] - Whether or not the block should be sealed
 * @returns {Function} - An interaction object
 */
function getBlockHeader() {
  let isSealed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  return pipe([makeGetBlockHeader, ix => {
    ix.block.isSealed = isSealed;
    return Ok(ix);
  }]);
}

/**
 * @description - A builder function that returns all a collection containing a list of transaction ids by its collection id
 * NOTE:
 * - The block range provided must be from the current spork. All events emitted during past sporks is current unavailable.
 * @param {string} [id] - The id of the collection to get
 * @returns {Function} - An interaction object
 */
function getCollection() {
  let id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  return pipe([makeGetCollection, ix => {
    ix.collection.id = id;
    return ix;
  }]);
}

/**
 * @description - A builder function that returns the status of transaction
 * NOTE: The transactionID provided must be from the current spork.
 * @param {string} transactionId - The id of the transaction to get status
 * @returns {Function} - An interaction object
 */
function getTransactionStatus(transactionId) {
  return pipe([makeGetTransactionStatus, ix => {
    ix.transaction.id = transactionId;
    return Ok(ix);
  }]);
}

/**
 * @description - A builder function that returns a transaction
 * NOTE: The transactionID provided must be from the current spork.
 * @param {string} transactionId - The id of the transaction to get
 * @returns {Function} - An interaction object
 */
function getTransaction(transactionId) {
  return pipe([makeGetTransaction, ix => {
    ix.transaction.id = transactionId;
    return Ok(ix);
  }]);
}

function getNetworkParameters() {
  return pipe([makeGetNetworkParameters, ix => {
    return Ok(ix);
  }]);
}

function limit(computeLimit) {
  return ix => {
    ix.message.computeLimit = computeLimit;
    return ix;
  };
}

/**
 * @description A utility builder to be used with other builders to pass in arguments with a value and supported type
 * @param ax An array of arguments
 * @returns An interaction object
 */
function args(ax) {
  return pipe(ax.map(makeArgument));
}

/**
 * @description A utility builder to be used with fcl.args[...] to create FCL supported arguments for interactions
 * @param value The value of the argument
 * @param xform A function to transform the value
 * @returns An argument object
 */
function arg(value, xform) {
  return {
    value,
    xform
  };
}

function proposer(authz) {
  return prepAccount(authz, {
    role: TransactionRole.PROPOSER
  });
}

/**
 * @description - A builder function that adds payer account(s) to a transaction
 * @param {Function | Array.<Function>} ax - An account address or array of account addresses
 * @returns {Function} - An interaction object
 */
function payer() {
  let ax = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  if (!Array.isArray(ax)) ax = [ax];
  return pipe(ax.map(authz => {
    return prepAccount(authz, {
      role: TransactionRole.PAYER
    });
  }));
}

function ping() {
  return makePing;
}

function ref(refBlock) {
  return pipe([ix => {
    ix.message.refBlock = refBlock;
    return Ok(ix);
  }]);
}

function script() {
  return pipe([makeScript, put("ix.cadence", template(...arguments))]);
}

const DEFAULT_SCRIPT_ACCOUNTS = [];
const DEFUALT_REF = null;

/**
 * @description - A template builder to use a Cadence transaction for an interaction
 * @param {...*} args - The arguments to pass
 * @returns {Function} - An interaction object
 */
function transaction() {
  return pipe([makeTransaction, put("ix.cadence", template(...arguments)), ix => {
    ix.message.refBlock = ix.message.refBlock || DEFUALT_REF;
    ix.authorizations = ix.authorizations || DEFAULT_SCRIPT_ACCOUNTS;
    return Ok(ix);
  }]);
}

function voucherIntercept(fn) {
  return put("ix.voucher-intercept", fn);
}

/**
 * Subscribe to events with the given filter & parameters
 */
function subscribeEvents(_ref) {
  let {
    startBlockId,
    startHeight,
    eventTypes,
    addresses,
    contracts,
    heartbeatInterval
  } = _ref;
  invariant$1(!(startBlockId && startHeight), `SDK Subscribe Events Error: Cannot set both startBlockId and startHeight.`);
  return pipe([makeSubscribeEvents, ix => {
    ix.subscribeEvents.startBlockId = startBlockId ?? null;
    ix.subscribeEvents.startHeight = startHeight ?? null;
    ix.subscribeEvents.eventTypes = eventTypes ?? null;
    ix.subscribeEvents.addresses = addresses ?? null;
    ix.subscribeEvents.contracts = contracts ?? null;
    ix.subscribeEvents.heartbeatInterval = heartbeatInterval ?? null;
    return Ok(ix);
  }]);
}

const resolveProposerSequenceNumber = _ref => {
  let {
    node
  } = _ref;
  return async ix => {
    if (!isTransaction(ix)) return Ok(ix);
    if (ix.accounts[ix.proposer].sequenceNum) return Ok(ix);
    const sendFn = await config.first(["sdk.transport", "sdk.send"], send$1);
    invariant$1(sendFn, `Required value for sdk.transport is not defined in config. See: ${"https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21"}`);
    const response$1 = await sendFn(await build([getAccount(ix.accounts[ix.proposer].addr)]), {
      config,
      response: response,
      Buffer,
      ix: ixModule
    }, {
      node
    });
    const decoded = await decodeResponse(response$1);
    ix.accounts[ix.proposer].sequenceNum = decoded.keys[ix.accounts[ix.proposer].keyId].sequenceNumber;
    return Ok(ix);
  };
};

async function getRefId(opts) {
  const node = await config().get("accessNode.api");
  const sendFn = await config.first(["sdk.transport", "sdk.send"], send$1);
  invariant$1(sendFn, `Required value for sdk.transport is not defined in config. See: ${"https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21"}`);
  var ix;
  ix = await pipe(initInteraction(), [getBlock()]);
  ix = await sendFn(ix, {
    config,
    response,
    Buffer,
    ix: ixModule
  }, {
    node
  });
  ix = await decodeResponse(ix);
  return ix.id;
}
function resolveRefBlockId(opts) {
  return async ix => {
    if (!isTransaction(ix)) return Ok(ix);
    if (ix.message.refBlock) return Ok(ix);
    ix.message.refBlock = await getRefId();
    return Ok(ix);
  };
}

function mockAccountResponse(ix) {
  let numberOfKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;
  // prettier-ignore
  invariant$1(ix.account, "mockAccountResponse(ix) -- ix.account is missing", ix);
  // prettier-ignore
  invariant$1(ix.account.addr, "mockAccountResponse(ix) -- ix.account.addr is missing", ix);
  const address = ix.account.addr;
  return {
    account: {
      addr: address,
      keys: Array.from({
        length: numberOfKeys
      }, (_, i) => ({
        index: i,
        sequenceNumber: 42
      }))
    }
  };
}
function mockGetBlockResponse(ix) {
  return {
    tag: "GET_BLOCK",
    block: {
      id: "32"
    }
  };
}
const identity = v => v;
function mockSend() {
  let fallback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : identity;
  return async function execSend(ix) {
    ix = await ix;
    switch (true) {
      case isGetAccount(ix):
        return mockAccountResponse(ix);
      case isGetBlock(ix):
        return mockGetBlockResponse();
      default:
        return fallback(ix);
    }
  };
}

const idof = acct => `${withPrefix(acct.addr)}-${acct.keyId}`;
function sig(opts) {
  return ["SIGNATURE", opts.addr, opts.keyId].join(".");
}
function authzFn() {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return function (account) {
    const acct = {
      ...account,
      ...opts,
      resolve: null,
      signingFunction: opts.signingFunction || account.signingFunction || fallbackSigningFunction
    };
    return acct;
    function fallbackSigningFunction(_signable) {
      return {
        addr: acct.addr,
        keyId: acct.keyId,
        signature: sig(acct)
      };
    }
  };
}
function authzResolve() {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return function (account) {
    const {
      tempId,
      ...rest
    } = opts;
    return {
      ...account,
      tempId: tempId || "WITH_RESOLVE",
      resolve: authzFn(rest)
    };
  };
}
const ROLE = {
  proposer: false,
  authorizer: false,
  payer: false
};
function authzResolveMany() {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
    authorizations: []
  };
  return function (account) {
    const tempId = opts.tempId || "AUTHZ_RESOLVE_MANY";
    return {
      ...account,
      tempId,
      resolve: () => [opts.proposer && authzFn(opts.proposer)({
        role: {
          ...ROLE,
          proposer: true
        }
      }), ...opts.authorizations.map(authzFn).map(d => d({
        role: {
          ...ROLE,
          authorizer: true
        }
      })), opts.payer && authzFn(opts.payer)({
        role: {
          ...ROLE,
          payer: true
        }
      })].filter(Boolean)
    };
  };
}
function authzDeepResolveMany() {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
    authorizations: []
  };
  let depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  return function (account) {
    const tempId = opts.tempId || "AUTHZ_DEEP_RESOLVE_MANY";
    return {
      ...account,
      tempId,
      resolve: depth > 0 ? authzDeepResolveMany(opts, depth - 1)(account).resolve : authzResolveMany(opts)(account).resolve
    };
  };
}

const run = function () {
  let fns = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return build([ref("123"), ...fns]).then(resolve);
};

var index = /*#__PURE__*/Object.freeze({
  __proto__: null,
  mockSend: mockSend,
  authzFn: authzFn,
  authzResolve: authzResolve,
  authzResolveMany: authzResolveMany,
  authzDeepResolveMany: authzDeepResolveMany,
  sig: sig,
  idof: idof,
  run: run
});

const VERSION = "1.5.1" ;

// Deprecated
const params = params => logger.log.deprecate({
  pkg: "FCL/SDK",
  message: `The params builder has been removed from the Flow JS-SDK/FCL.`,
  transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0001-deprecate-params",
  level: logger.LEVELS.error
});
const param = params => logger.log.deprecate({
  pkg: "FCL/SDK",
  message: `The param builder has been removed from the Flow JS-SDK/FCL.`,
  transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0001-deprecate-params",
  level: logger.LEVELS.error
});

export { index as TestUtils, VERSION, account, arg, args, atBlockHeight, atBlockId, authorization, authorizations, block, build, createSignableVoucher, decode, destroy, encodeMessageFromSignable, encodeTransactionEnvelope, encodeTransactionPayload, encodeTxIdFromVoucher, get, getAccount, getBlock, getBlockHeader, getCollection, getEvents, getEventsAtBlockHeightRange, getEventsAtBlockIds, getNetworkParameters, getNodeVersionInfo, getTransaction, getTransactionStatus, initInteraction, interaction, invariant, isBad, isGetAccount, isGetBlock, isGetBlockHeader, isGetCollection, isGetEvents, isGetNetworkParameters, isGetNodeVersionInfo, isGetTransaction, isGetTransactionStatus, isOk, isPing, isScript, isTransaction, isUnknown, limit, nodeVersionInfo, param, params, payer, ping, pipe, proposer, put, ref, resolve, resolveAccounts, resolveArguments, resolveCadence, resolveFinalNormalization, resolveProposerSequenceNumber, resolveRefBlockId, resolveSignatures, resolveValidators, resolveVoucherIntercept, response, script, send, subscribeEvents, transaction, update, validator, voucherIntercept, voucherToTxId, why };
//# sourceMappingURL=sdk.module.js.map
