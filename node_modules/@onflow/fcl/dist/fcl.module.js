import { buildMessageHandler, serviceEndpoint, normalizePollingResponse, CORE_STRATEGIES, getExecHttpPost, pluginRegistry, getMutate, getCurrentUser, initServiceRegistry } from '@onflow/fcl-core';
export { AppUtils, InteractionTemplateUtils, TestUtils, VERSION, WalletUtils, account, arg, args, atBlockHeight, atBlockId, authorization, authorizations, block, build, cadence, cdc, config, createSignableVoucher, decode, discovery, display, events, getAccount, getBlock, getBlockHeader, getChainId, getCollection, getEvents, getEventsAtBlockHeightRange, getEventsAtBlockIds, getNetworkParameters, getNodeVersionInfo, getTransaction, getTransactionStatus, invariant, isBad, isOk, limit, nodeVersionInfo, param, params, payer, ping, pipe, pluginRegistry, proposer, query, ref, sansPrefix, script, send, serialize, subscribeEvents, t, transaction, tx, validator, verifyUserSignatures, voucherIntercept, voucherToTxId, why, withPrefix } from '@onflow/fcl-core';
import { config } from '@onflow/config';
import { invariant } from '@onflow/util-invariant';
import { uid } from '@onflow/util-uid';
import * as fclWc from '@onflow/fcl-wc';

const FRAME = "FCL_IFRAME";
const FRAME_STYLES = `
  position:fixed;
  top: 0px;
  right: 0px;
  bottom: 0px;
  left: 0px;
  height: 100%;
  width: 100vw;
  display:block;
  background:rgba(0,0,0,0.25);
  z-index: 2147483647;
  box-sizing: border-box;
  color-scheme: light;
`;
function renderFrame(src) {
  invariant(!document.getElementById(FRAME), "Attempt at triggering multiple Frames", {
    src
  });
  const $frame = document.createElement("iframe");
  $frame.src = src;
  $frame.id = FRAME;
  $frame.allow = "usb *; hid *";
  $frame.frameBorder = "0";
  $frame.style.cssText = FRAME_STYLES;
  document.body.append($frame);
  const unmount = () => {
    if (document.getElementById(FRAME)) {
      document.getElementById(FRAME).remove();
    }
  };
  return [$frame.contentWindow, unmount];
}

const POP = "FCL_POP";
let popup = null;
let previousUrl$1 = null;
function popupWindow(url, windowName, win, w, h) {
  const y = win.top.outerHeight / 2 + win.top.screenY - h / 2;
  const x = win.top.outerWidth / 2 + win.top.screenX - w / 2;
  const popup = win.open(url, windowName, `toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=no, copyhistory=no, width=${w}, height=${h}, top=${y}, left=${x}`);
  if (!popup) throw new Error("Popup failed to open (was it blocked by a popup blocker?)");
  return popup;
}
function renderPop(src) {
  if (popup == null || popup?.closed) {
    popup = popupWindow(src, POP, window, 640, 770);
  } else if (previousUrl$1 !== src) {
    popup.location.replace(src);
    popup.focus();
  } else {
    popup.focus();
  }
  previousUrl$1 = src;
  const unmount = () => {
    if (popup && !popup.closed) {
      popup.close();
    }
    popup = null;
  };
  return [popup, unmount];
}

let tab$1 = null;
let previousUrl = null;
function renderTab(src) {
  if (tab$1 == null || tab$1?.closed) {
    tab$1 = window.open(src, "_blank");
    if (!tab$1) throw new Error("Tab failed to open (was it blocked by the browser?)");
  } else if (previousUrl !== src) {
    tab$1.location.replace(src);
    tab$1.focus();
  } else {
    tab$1.focus();
  }
  previousUrl = src;
  const unmount = () => {
    if (tab$1 && !tab$1.closed) {
      tab$1.close();
    }
    tab$1 = null;
  };
  return [tab$1, unmount];
}

const isServerSide = () => typeof window === "undefined";
const getSessionStorage = () => {
  try {
    const SESSION_STORAGE = {
      can: !isServerSide(),
      get: async key => JSON.parse(sessionStorage.getItem(key)),
      put: async (key, value) => sessionStorage.setItem(key, JSON.stringify(value))
    };
    return SESSION_STORAGE;
  } catch (error) {
    return null;
  }
};
const getDefaultConfig = () => {
  return {
    "discovery.wallet.method.default": "IFRAME/RPC",
    "fcl.storage.default": getSessionStorage()
  };
};

const noop$3 = () => {};
function frame(service) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (service == null) return {
    send: noop$3,
    close: noop$3
  };
  const onClose = opts.onClose || noop$3;
  const onMessage = opts.onMessage || noop$3;
  const onReady = opts.onReady || noop$3;
  const onResponse = opts.onResponse || noop$3;
  const handler = buildMessageHandler({
    close,
    send,
    onReady,
    onResponse,
    onMessage
  });
  window.addEventListener("message", handler);
  const [$frame, unmount] = renderFrame(serviceEndpoint(service));
  return {
    send,
    close
  };
  function close() {
    try {
      window.removeEventListener("message", handler);
      unmount();
      onClose();
    } catch (error) {
      console.error("Frame Close Error", error);
    }
  }
  function send(msg) {
    try {
      $frame.postMessage(JSON.parse(JSON.stringify(msg || {})), "*");
    } catch (error) {
      console.error("Frame Send Error", msg, error);
    }
  }
}

const VERSION = "1.11.0" ;

function execIframeRPC(_ref) {
  let {
    service,
    body,
    config,
    opts
  } = _ref;
  return new Promise((resolve, reject) => {
    const id = uid();
    const includeOlderJsonRpcCall = opts.includeOlderJsonRpcCall;
    frame(service, {
      async onReady(_, _ref2) {
        let {
          send
        } = _ref2;
        try {
          send({
            type: "FCL:VIEW:READY:RESPONSE",
            fclVersion: VERSION,
            body,
            service: {
              params: service.params,
              data: service.data,
              type: service.type
            },
            config
          });
          send({
            fclVersion: VERSION,
            type: "FCL:FRAME:READY:RESPONSE",
            body,
            service: {
              params: service.params,
              data: service.data,
              type: service.type
            },
            config,
            deprecated: {
              message: "FCL:FRAME:READY:RESPONSE is deprecated and replaced with type: FCL:VIEW:READY:RESPONSE"
            }
          });
          if (includeOlderJsonRpcCall) {
            send({
              jsonrpc: "2.0",
              id: id,
              method: "fcl:sign",
              params: [body, service.params],
              deprecated: {
                message: "jsonrpc is deprecated and replaced with type: FCL:VIEW:READY:RESPONSE"
              }
            });
          }
        } catch (error) {
          throw error;
        }
      },
      onResponse(e, _ref3) {
        let {
          close
        } = _ref3;
        try {
          if (typeof e.data !== "object") return;
          const resp = normalizePollingResponse(e.data);
          switch (resp.status) {
            case "APPROVED":
              resolve(resp.data);
              close();
              break;
            case "DECLINED":
              reject(`Declined: ${resp.reason || "No reason supplied"}`);
              close();
              break;
            case "REDIRECT":
              resolve(resp);
              close();
              break;
            default:
              reject(`Declined: No reason supplied`);
              close();
              break;
          }
        } catch (error) {
          console.error("execIframeRPC onResponse error", error);
          throw error;
        }
      },
      onMessage(e, _ref4) {
        let {
          close
        } = _ref4;
        try {
          if (typeof e.data !== "object") return;
          if (e.data.jsonrpc !== "2.0") return;
          if (e.data.id !== id) return;
          const resp = normalizePollingResponse(e.data.result);
          switch (resp.status) {
            case "APPROVED":
              resolve(resp.data);
              close();
              break;
            case "DECLINED":
              reject(`Declined: ${resp.reason || "No reason supplied"}`);
              close();
              break;
            case "REDIRECT":
              resolve(resp);
              close();
              break;
            default:
              reject(`Declined: No reason supplied`);
              close();
              break;
          }
        } catch (error) {
          console.error("execIframeRPC onMessage error", error);
          throw error;
        }
      },
      onClose() {
        reject(`Declined: Externally Halted`);
      }
    });
  });
}

const noop$2 = () => {};
function pop(service) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (service == null) return {
    send: noop$2,
    close: noop$2
  };
  const onClose = opts.onClose || noop$2;
  const onMessage = opts.onMessage || noop$2;
  const onReady = opts.onReady || noop$2;
  const onResponse = opts.onResponse || noop$2;
  const handler = buildMessageHandler({
    close,
    send,
    onReady,
    onResponse,
    onMessage
  });
  window.addEventListener("message", handler);
  const [$pop, unmount] = renderPop(serviceEndpoint(service));
  const timer = setInterval(function () {
    if ($pop && $pop.closed) {
      close();
    }
  }, 500);
  return {
    send,
    close
  };
  function close() {
    try {
      window.removeEventListener("message", handler);
      clearInterval(timer);
      unmount();
      onClose();
    } catch (error) {
      console.error("Popup Close Error", error);
    }
  }
  function send(msg) {
    try {
      $pop.postMessage(JSON.parse(JSON.stringify(msg || {})), "*");
    } catch (error) {
      console.error("Popup Send Error", msg, error);
    }
  }
}

function execPopRPC(_ref) {
  let {
    service,
    body,
    config,
    opts
  } = _ref;
  return new Promise((resolve, reject) => {
    const id = uid();
    const {
      redir,
      includeOlderJsonRpcCall
    } = opts;
    pop(service, {
      async onReady(_, _ref2) {
        let {
          send
        } = _ref2;
        try {
          send({
            fclVersion: VERSION,
            type: "FCL:VIEW:READY:RESPONSE",
            body,
            service: {
              params: service.params,
              data: service.data,
              type: service.type
            },
            config
          });
          send({
            fclVersion: VERSION,
            type: "FCL:FRAME:READY:RESPONSE",
            body,
            service: {
              params: service.params,
              data: service.data,
              type: service.type
            },
            config,
            deprecated: {
              message: "FCL:FRAME:READY:RESPONSE is deprecated and replaced with type: FCL:VIEW:READY:RESPONSE"
            }
          });
          if (includeOlderJsonRpcCall) {
            send({
              jsonrpc: "2.0",
              id: id,
              method: "fcl:sign",
              params: [body, service.params]
            });
          }
        } catch (error) {
          throw error;
        }
      },
      onResponse(e, _ref3) {
        let {
          close
        } = _ref3;
        try {
          if (typeof e.data !== "object") return;
          const resp = normalizePollingResponse(e.data);
          switch (resp.status) {
            case "APPROVED":
              resolve(resp.data);
              !redir && close();
              break;
            case "DECLINED":
              reject(`Declined: ${resp.reason || "No reason supplied"}`);
              close();
              break;
            case "REDIRECT":
              resolve(resp);
              close();
              break;
            default:
              reject(`Declined: No reason supplied`);
              close();
              break;
          }
        } catch (error) {
          console.error("execPopRPC onResponse error", error);
          throw error;
        }
      },
      onMessage(e, _ref4) {
        let {
          close
        } = _ref4;
        try {
          if (typeof e.data !== "object") return;
          if (e.data.jsonrpc !== "2.0") return;
          if (e.data.id !== id) return;
          const resp = normalizePollingResponse(e.data.result);
          switch (resp.status) {
            case "APPROVED":
              resolve(resp.data);
              !redir && close();
              break;
            case "DECLINED":
              reject(`Declined: ${resp.reason || "No reason supplied"}`);
              close();
              break;
            case "REDIRECT":
              resolve(resp);
              close();
              break;
            default:
              reject(`Declined: No reason supplied`);
              close();
              break;
          }
        } catch (error) {
          console.error("execPopRPC onMessage error", error);
          throw error;
        }
      },
      onClose() {
        reject(`Declined: Externally Halted`);
      }
    });
  });
}

const noop$1 = () => {};
function tab(service) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (service == null) return {
    send: noop$1,
    close: noop$1
  };
  const onClose = opts.onClose || noop$1;
  const onMessage = opts.onMessage || noop$1;
  const onReady = opts.onReady || noop$1;
  const onResponse = opts.onResponse || noop$1;
  const handler = buildMessageHandler({
    close,
    send,
    onReady,
    onResponse,
    onMessage
  });
  window.addEventListener("message", handler);
  const [$tab, unmount] = renderTab(serviceEndpoint(service));
  const timer = setInterval(function () {
    if ($tab && $tab.closed) {
      close();
    }
  }, 500);
  return {
    send,
    close
  };
  function close() {
    try {
      window.removeEventListener("message", handler);
      clearInterval(timer);
      unmount();
      onClose();
    } catch (error) {
      console.error("Tab Close Error", error);
    }
  }
  function send(msg) {
    try {
      $tab.postMessage(JSON.parse(JSON.stringify(msg || {})), "*");
    } catch (error) {
      console.error("Tab Send Error", msg, error);
    }
  }
}

function execTabRPC(_ref) {
  let {
    service,
    body,
    config,
    opts
  } = _ref;
  return new Promise((resolve, reject) => {
    const id = uid();
    const {
      redir,
      includeOlderJsonRpcCall
    } = opts;
    tab(service, {
      async onReady(_, _ref2) {
        let {
          send
        } = _ref2;
        try {
          send({
            fclVersion: VERSION,
            type: "FCL:VIEW:READY:RESPONSE",
            body,
            service: {
              params: service.params,
              data: service.data,
              type: service.type
            },
            config
          });
          send({
            fclVersion: VERSION,
            type: "FCL:FRAME:READY:RESPONSE",
            body,
            service: {
              params: service.params,
              data: service.data,
              type: service.type
            },
            config,
            deprecated: {
              message: "FCL:FRAME:READY:RESPONSE is deprecated and replaced with type: FCL:VIEW:READY:RESPONSE"
            }
          });
          if (includeOlderJsonRpcCall) {
            send({
              jsonrpc: "2.0",
              id: id,
              method: "fcl:sign",
              params: [body, service.params]
            });
          }
        } catch (error) {
          throw error;
        }
      },
      onResponse(e, _ref3) {
        let {
          close
        } = _ref3;
        try {
          if (typeof e.data !== "object") return;
          const resp = normalizePollingResponse(e.data);
          switch (resp.status) {
            case "APPROVED":
              resolve(resp.data);
              !redir && close();
              break;
            case "DECLINED":
              reject(`Declined: ${resp.reason || "No reason supplied"}`);
              close();
              break;
            case "REDIRECT":
              resolve(resp);
              close();
              break;
            default:
              reject(`Declined: No reason supplied`);
              close();
              break;
          }
        } catch (error) {
          console.error("execPopRPC onResponse error", error);
          throw error;
        }
      },
      onMessage(e, _ref4) {
        let {
          close
        } = _ref4;
        try {
          if (typeof e.data !== "object") return;
          if (e.data.jsonrpc !== "2.0") return;
          if (e.data.id !== id) return;
          const resp = normalizePollingResponse(e.data.result);
          switch (resp.status) {
            case "APPROVED":
              resolve(resp.data);
              !redir && close();
              break;
            case "DECLINED":
              reject(`Declined: ${resp.reason || "No reason supplied"}`);
              close();
              break;
            case "REDIRECT":
              resolve(resp);
              close();
              break;
            default:
              reject(`Declined: No reason supplied`);
              close();
              break;
          }
        } catch (error) {
          console.error("execPopRPC onMessage error", error);
          throw error;
        }
      },
      onClose() {
        reject(`Declined: Externally Halted`);
      }
    });
  });
}

const noop = () => {};
function extension(service) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (service == null) return {
    send: noop,
    close: noop
  };
  const onClose = opts.onClose || noop;
  const onMessage = opts.onMessage || noop;
  const onReady = opts.onReady || noop;
  const onResponse = opts.onResponse || noop;
  const handler = buildMessageHandler({
    close,
    send,
    onReady,
    onResponse,
    onMessage
  });
  window.addEventListener("message", handler);
  send({
    service
  });
  return {
    send,
    close
  };
  function close() {
    try {
      window.removeEventListener("message", handler);
      onClose();
    } catch (error) {
      console.error("Ext Close Error", error);
    }
  }
  function send(msg) {
    try {
      window && window.postMessage(JSON.parse(JSON.stringify(msg || {})), "*");
    } catch (error) {
      console.error("Ext Send Error", msg, error);
    }
  }
}

function execExtRPC(_ref) {
  let {
    service,
    body,
    config,
    opts
  } = _ref;
  return new Promise((resolve, reject) => {
    extension(service, {
      async onReady(_, _ref2) {
        let {
          send
        } = _ref2;
        try {
          send({
            fclVersion: VERSION,
            type: "FCL:VIEW:READY:RESPONSE",
            body,
            service: {
              params: service.params,
              data: service.data,
              type: service.type
            },
            config
          });
        } catch (error) {
          throw error;
        }
      },
      onResponse(e, _ref3) {
        let {
          close
        } = _ref3;
        try {
          if (typeof e.data !== "object") return;
          const resp = normalizePollingResponse(e.data);
          switch (resp.status) {
            case "APPROVED":
              resolve(resp.data);
              close();
              break;
            case "DECLINED":
              reject(`Declined: ${resp.reason || "No reason supplied"}`);
              close();
              break;
            case "REDIRECT":
              resolve(resp);
              close();
              break;
            default:
              reject(`Declined: No reason supplied`);
              close();
              break;
          }
        } catch (error) {
          console.error("execExtRPC onResponse error", error);
          throw error;
        }
      },
      onClose() {
        reject(`Declined: Externally Halted`);
      }
    });
  });
}

const NOT_IMPLEMENTED = () => {
  throw new Error("Strategy util has not been implemented on this platform");
};
const VIEWS = {
  "VIEW/IFRAME": renderFrame,
  "VIEW/POP": renderPop,
  "VIEW/TAB": renderTab,
  "VIEW/MOBILE_BROWSER": NOT_IMPLEMENTED,
  "VIEW/DEEPLINK": NOT_IMPLEMENTED
};
async function execLocal(service) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    serviceEndpoint: () => {}
  };
  const {
    serviceEndpoint
  } = opts;
  try {
    return VIEWS[service.method](serviceEndpoint(service), opts);
  } catch (error) {
    console.error("execLocal({service, opts = {}})", error, {
      service,
      opts
    });
    throw error;
  }
}

const coreStrategies = {
  [CORE_STRATEGIES["HTTP/RPC"]]: getExecHttpPost(execLocal),
  [CORE_STRATEGIES["HTTP/POST"]]: getExecHttpPost(execLocal),
  [CORE_STRATEGIES["IFRAME/RPC"]]: execIframeRPC,
  [CORE_STRATEGIES["POP/RPC"]]: execPopRPC,
  [CORE_STRATEGIES["TAB/RPC"]]: execTabRPC,
  [CORE_STRATEGIES["EXT/RPC"]]: execExtRPC
};

const isServer = typeof window === "undefined";
const getMetadata = config => {
  const appTitle = config["app.detail.title"];
  const appIcon = config["app.detail.icon"];
  const appDescription = config["app.detail.description"];
  const appUrl = config["app.detail.url"];
  return {
    name: appTitle ?? document.title,
    description: appDescription ?? "",
    url: appUrl ?? window.location.origin,
    icons: appIcon ? [appIcon] : []
  };
};
function initFclWcLoader() {
  // We cannot load WalletConnect plugin on server side
  if (isServer) {
    return;
  }

  // Use previous configuration to check for changes & notify the user that this is not possible
  let lastConfig = null;

  // Only the first configuration will be used
  let hasLoaded = false;
  config.subscribe(async fullConfig => {
    const wcConfig = {
      "walletconnect.projectId": fullConfig["walletconnect.projectId"],
      "app.detail.title": fullConfig["app.detail.title"],
      "app.detail.icon": fullConfig["app.detail.icon"],
      "app.detail.description": fullConfig["app.detail.description"],
      "app.detail.url": fullConfig["app.detail.url"]
    };
    const projectId = wcConfig["walletconnect.projectId"];

    // Check if the plugin is already loaded by this loader, but with different configuration
    // The plugin can only be loaded once
    const previousConfig = lastConfig;
    lastConfig = JSON.stringify(wcConfig, null, 2);
    if (hasLoaded) {
      if (previousConfig !== lastConfig) {
        console.warn(`FCL WalletConnect Plugin has been already loaded with different configuration. It is not possible to change the configuration after the plugin has been loaded.

Previous configuration:
${previousConfig}

Current configuration:
${lastConfig}`);
      }
      return;
    }

    // If the configuration is not set, we do not load the plugin
    const isConfigured = !!projectId;
    if (!isConfigured) {
      return;
    }
    invariant(!!projectId, "FCL Configuration value for 'walletconnect.projectId' is required");

    // Check if the plugin is already loaded manually
    // Usually this won't happen as it is more likely that the plugin will be loaded by this loader
    // before the developer has a chance to load it manually, but it's good to check
    if (pluginRegistry.getPlugins().has(fclWc.SERVICE_PLUGIN_NAME)) {
      if (!hasLoaded) {
        console.warn("It seems like the FCL WalletConnect plugins has been already loaded manually. This is no longer necessary, please see the documentation for more information.");
      }
      hasLoaded = true;
      return;
    }
    hasLoaded = true;

    // Load the plugin if not already loaded
    // We must lazy load the plugin to avoid race conditions
    // where the developer attempts to use the plugin before
    // our loader applies the configuration
    const {
      FclWcServicePlugin
    } = fclWc.initLazy({
      projectId,
      metadata: getMetadata(wcConfig)
    });
    pluginRegistry.add([FclWcServicePlugin]);
  });
}

const mutate = getMutate({
  platform: "web"
});
const currentUser = getCurrentUser({
  platform: "web"
});
const authenticate = function () {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return currentUser().authenticate(opts);
};
const unauthenticate = () => currentUser().unauthenticate();
const reauthenticate = function () {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  currentUser().unauthenticate();
  return currentUser().authenticate(opts);
};
const signUp = function () {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return currentUser().authenticate(opts);
};
const logIn = function () {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return currentUser().authenticate(opts);
};
const authz = currentUser().authorization;
config(getDefaultConfig());
initServiceRegistry({
  coreStrategies
});

// Automatically load fcl-wc plugin
// Based on the user's config
initFclWcLoader();

export { authenticate, authz, currentUser, logIn, mutate, reauthenticate, signUp, unauthenticate };
//# sourceMappingURL=fcl.module.js.map
