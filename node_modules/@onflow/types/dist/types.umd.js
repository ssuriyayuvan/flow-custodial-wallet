(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@onflow/util-logger')) :
  typeof define === 'function' && define.amd ? define(['exports', '@onflow/util-logger'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.onflowTypes = {}, global.utilLogger));
})(this, (function (exports, utilLogger) { 'use strict';

  /**
   * @deprecated Reference values cannot be imported into the Cadence interpreter, will be removed in future versions
   */

  /**
   * Creates a type descriptor for a given type
   * @param label - The label for the type
   * @param asArgument - A function that converts the type to a JsonCdcType
   * @param asInjection - A function which returns the argument as is
   * @returns A type descriptor
   * @internal
   */
  const typedef = (label, asArgument, asInjection) => ({
    label,
    asArgument,
    asInjection: x => {
      utilLogger.log.deprecate({
        pkg: "@onflow/types",
        subject: `Passing in ${label} as value for ${label}`,
        message: `Going forward, use ${label} as value for ${label}.`
      });
      return asInjection(x);
    }
  });
  const isArray = d => Array.isArray(d);
  const isObj = d => typeof d === "object";
  const isNull = d => d == null;
  const isBoolean = d => typeof d === "boolean";
  const isNumber = d => typeof d === "number";
  const isInteger = d => Number.isInteger(d);
  const isString = d => typeof d === "string";
  const throwTypeError = msg => {
    throw new Error("Type Error: " + msg);
  };
  const numberValuesDeprecationNotice = type => {
    utilLogger.log.deprecate({
      pkg: "@onflow/types",
      subject: `Passing in Number as value for ${type}`,
      message: `Going forward, use String as value for ${type}.`,
      transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/types/WARNINGS.md#0002-[U]Int*-and-Word*-as-Number"
    });
  };
  let identityDeprecationShown = false;
  /**
   * @deprecated will be removed in v2.0.0
   */
  const Identity = {
    label: "Identity",
    asArgument: v => {
      if (!identityDeprecationShown) {
        utilLogger.log.deprecate({
          pkg: "@onflow/types",
          subject: "Identity",
          message: "Identity type is deprecated and will be removed in v2.0.0.  Please remove it from your code."
        });
        identityDeprecationShown = true;
      }
      return v;
    },
    asInjection: v => v
  };
  const UInt = typedef("UInt", v => {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("UInt");
      return {
        type: "UInt",
        value: v.toString()
      };
    }
    if (isString(v)) {
      return {
        type: "UInt",
        value: v
      };
    }
    return throwTypeError("Expected Positive Integer for type Unsigned Int");
  }, v => v);
  const Int = typedef("Int", v => {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("Int");
      return {
        type: "Int",
        value: v.toString()
      };
    }
    if (isString(v)) {
      return {
        type: "Int",
        value: v
      };
    }
    return throwTypeError("Expected Integer for type Int");
  }, v => v);
  const UInt8 = typedef("UInt8", v => {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("UInt8");
      return {
        type: "UInt8",
        value: v.toString()
      };
    }
    if (isString(v)) {
      return {
        type: "UInt8",
        value: v
      };
    }
    return throwTypeError("Expected integer for UInt8");
  }, v => v);
  const Int8 = typedef("Int8", v => {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("Int8");
      return {
        type: "Int8",
        value: v.toString()
      };
    }
    if (isString(v)) {
      return {
        type: "Int8",
        value: v
      };
    }
    return throwTypeError("Expected positive integer for Int8");
  }, v => v);
  const UInt16 = typedef("UInt16", v => {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("UInt16");
      return {
        type: "UInt16",
        value: v.toString()
      };
    }
    if (isString(v)) {
      return {
        type: "UInt16",
        value: v
      };
    }
    return throwTypeError("Expected integer for UInt16");
  }, v => v);
  const Int16 = typedef("Int16", v => {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("Int16");
      return {
        type: "Int16",
        value: v.toString()
      };
    }
    if (isString(v)) {
      return {
        type: "Int16",
        value: v
      };
    }
    return throwTypeError("Expected positive integer for Int16");
  }, v => v);
  const UInt32 = typedef("UInt32", v => {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("UInt32");
      return {
        type: "UInt32",
        value: v.toString()
      };
    }
    if (isString(v)) {
      return {
        type: "UInt32",
        value: v
      };
    }
    return throwTypeError("Expected integer for UInt32");
  }, v => v);
  const Int32 = typedef("Int32", v => {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("Int32");
      return {
        type: "Int32",
        value: v.toString()
      };
    }
    if (isString(v)) {
      return {
        type: "Int32",
        value: v
      };
    }
    return throwTypeError("Expected positive integer for Int32");
  }, v => v);
  const UInt64 = typedef("UInt64", v => {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("UInt64");
      return {
        type: "UInt64",
        value: v.toString()
      };
    }
    if (isString(v)) {
      return {
        type: "UInt64",
        value: v
      };
    }
    return throwTypeError("Expected integer for UInt64");
  }, v => v);
  const Int64 = typedef("Int64", v => {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("Int64");
      return {
        type: "Int64",
        value: v.toString()
      };
    }
    if (isString(v)) {
      return {
        type: "Int64",
        value: v
      };
    }
    return throwTypeError("Expected positive integer for Int64");
  }, v => v);
  const UInt128 = typedef("UInt128", v => {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("UInt128");
      return {
        type: "UInt128",
        value: v.toString()
      };
    }
    if (isString(v)) {
      return {
        type: "UInt128",
        value: v
      };
    }
    return throwTypeError("Expected integer for UInt128");
  }, v => v);
  const Int128 = typedef("Int128", v => {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("Int128");
      return {
        type: "Int128",
        value: v.toString()
      };
    }
    if (isString(v)) {
      return {
        type: "Int128",
        value: v
      };
    }
    return throwTypeError("Expected positive integer for Int128");
  }, v => v);
  const UInt256 = typedef("UInt256", v => {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("UInt256");
      return {
        type: "UInt256",
        value: v.toString()
      };
    }
    if (isString(v)) {
      return {
        type: "UInt256",
        value: v
      };
    }
    return throwTypeError("Expected integer for UInt256");
  }, v => v);
  const Int256 = typedef("Int256", v => {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("Int256");
      return {
        type: "Int256",
        value: v.toString()
      };
    }
    if (isString(v)) {
      return {
        type: "Int256",
        value: v
      };
    }
    return throwTypeError("Expected integer for Int256");
  }, v => v);
  const Word8 = typedef("Word8", v => {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("Word8");
      return {
        type: "Word8",
        value: v.toString()
      };
    }
    if (isString(v)) {
      return {
        type: "Word8",
        value: v
      };
    }
    return throwTypeError("Expected positive number for Word8");
  }, v => v);
  const Word16 = typedef("Word16", v => {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("Word16");
      return {
        type: "Word16",
        value: v.toString()
      };
    }
    if (isString(v)) {
      return {
        type: "Word16",
        value: v
      };
    }
    return throwTypeError("Expected positive number for Word16");
  }, v => v);
  const Word32 = typedef("Word32", v => {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("Word32");
      return {
        type: "Word32",
        value: v.toString()
      };
    }
    if (isString(v)) {
      return {
        type: "Word32",
        value: v
      };
    }
    return throwTypeError("Expected positive number for Word32");
  }, v => v);
  const Word64 = typedef("Word64", v => {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("Word64");
      return {
        type: "Word64",
        value: v.toString()
      };
    }
    if (isString(v)) {
      return {
        type: "Word64",
        value: v
      };
    }
    return throwTypeError("Expected positive number for Word64");
  }, v => v);
  const Word128 = typedef("Word128", v => {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("Word128");
      return {
        type: "Word128",
        value: v.toString()
      };
    }
    if (isString(v)) {
      return {
        type: "Word128",
        value: v
      };
    }
    return throwTypeError("Expected positive number for Word128");
  }, v => v);
  const Word256 = typedef("Word256", v => {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("Word256");
      return {
        type: "Word256",
        value: v.toString()
      };
    }
    if (isString(v)) {
      return {
        type: "Word256",
        value: v
      };
    }
    return throwTypeError("Expected positive number for Word256");
  }, v => v);
  const UFix64AndFix64NumberDeprecationNotice = () => {
    utilLogger.log.deprecate({
      subject: "Passing in Numbers as values for Fix64 and UFix64 types",
      pkg: "@onflow/types",
      transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/types/WARNINGS.md#0001-[U]Fix64-as-Number"
    });
  };
  const UFix64 = typedef("UFix64", v => {
    if (isString(v)) {
      const vParts = v.split(".");
      if (vParts.length !== 2) {
        return throwTypeError(`Expected one decimal but found ${vParts.length} in the [U]Fix64 value. Find out more about [U]Fix64 types here: https://docs.onflow.org/cadence/json-cadence-spec/#fixed-point-numbers`);
      }
      if (vParts[1].length == 0 || vParts[1].length > 8) {
        return throwTypeError(`Expected at least one digit, and at most 8 digits following the decimal of the [U]Fix64 value but found ${vParts[1].length} digits. Find out more about [U]Fix64 types here: https://docs.onflow.org/cadence/json-cadence-spec/#fixed-point-numbers`);
      }

      // make sure the number is extended to 8 decimal places so it matches cadence encoding of UFix values
      vParts[1] = vParts[1].padEnd(8, "0");
      v = vParts.join(".");
      return {
        type: "UFix64",
        value: v
      };
    } else if (isNumber(v)) {
      UFix64AndFix64NumberDeprecationNotice();
      return {
        type: "UFix64",
        value: v.toString()
      };
    }
    return throwTypeError("Expected String for UFix64");
  }, v => v);
  const Fix64 = typedef("Fix64", v => {
    if (isString(v)) {
      const vParts = v.split(".");
      if (vParts.length !== 2) {
        return throwTypeError(`Expected one decimal but found ${vParts.length} in the [U]Fix64 value. Find out more about [U]Fix64 types here: https://docs.onflow.org/cadence/json-cadence-spec/#fixed-point-numbers`);
      }
      if (vParts[1].length == 0 || vParts[1].length > 8) {
        return throwTypeError(`Expected at least one digit, and at most 8 digits following the decimal of the [U]Fix64 value but found ${vParts[1].length} digits. Find out more about [U]Fix64 types here: https://docs.onflow.org/cadence/json-cadence-spec/#fixed-point-numbers`);
      }

      // make sure the number is extended to 8 decimal places so it matches cadence encoding of Fix64 values
      vParts[1] = vParts[1].padEnd(8, "0");
      v = vParts.join(".");
      return {
        type: "Fix64",
        value: v
      };
    } else if (isNumber(v)) {
      UFix64AndFix64NumberDeprecationNotice();
      return {
        type: "Fix64",
        value: v.toString()
      };
    }
    return throwTypeError("Expected String for Fix64");
  }, v => v);
  const String = typedef("String", v => {
    if (isString(v)) return {
      type: "String",
      value: v
    };
    return throwTypeError("Expected String for type String");
  }, v => v);
  const Character = typedef("Character", v => {
    if (isString(v)) return {
      type: "Character",
      value: v
    };
    return throwTypeError("Expected Character for type Character");
  }, v => v);
  const Bool = typedef("Bool", v => {
    if (isBoolean(v)) return {
      type: "Bool",
      value: v
    };
    return throwTypeError("Expected Boolean for type Bool");
  }, v => v);
  const Address = typedef("Address", v => {
    if (isString(v)) return {
      type: "Address",
      value: v
    };
    return throwTypeError("Expected Address for type Address");
  }, v => v);
  const Void = typedef("Void", v => {
    if (!v || isNull(v)) return {
      type: "Void",
      value: null
    };
    return throwTypeError("Expected Void for type Void");
  }, v => v);
  const Optional = children => typedef("Optional", v => ({
    type: "Optional",
    value: isNull(v) ? null : children.asArgument(v)
  }), v => v);

  /**
   * @deprecated Reference values cannot be imported into the Cadence interpreter, will be removed in future versions
   */
  const Reference = typedef("Reference", v => {
    if (isObj(v)) return {
      type: "Reference",
      value: v
    };
    return throwTypeError("Expected Object for type Reference");
  }, v => v);
  const _Array = function () {
    let children = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    return typedef("Array", v => {
      return {
        type: "Array",
        value: isArray(children) ? children.map((c, i) => c.asArgument(v[i])) : v.map(x => children.asArgument(x))
      };
    }, v => v);
  };
  const Dictionary = function () {
    let children = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    return typedef("Dictionary", v => {
      const vIsArray = isArray(v);
      const childrenIsArray = isArray(children);
      if (isObj(v)) return {
        type: "Dictionary",
        value: childrenIsArray && vIsArray ? children.map((c, i) => ({
          key: c.key.asArgument(v[i].key),
          value: c.value.asArgument(v[i].value)
        })) : vIsArray && !childrenIsArray ? v.map(x => ({
          key: children.key.asArgument(x.key),
          value: children.value.asArgument(x.value)
        })) : !vIsArray && !childrenIsArray ? [{
          key: children.key.asArgument(v.key),
          value: children.value.asArgument(v.value)
        }] : throwTypeError("Invalid arguments for Dictionary.")
      };
      return throwTypeError("Expected Object for type Dictionary");
    }, v => v);
  };
  const Event = function (id) {
    let fields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    return typedef("Event", v => {
      if (isObj(v)) return {
        type: "Event",
        value: {
          id: id,
          fields: isArray(fields) ? fields.map((c, i) => ({
            name: v.fields[i].name,
            value: c.value.asArgument(v.fields[i].value)
          })) : v.fields.map(x => ({
            name: x.name,
            value: fields.value.asArgument(x.value)
          }))
        }
      };
      return throwTypeError("Expected Object for type Event");
    }, v => v);
  };
  const Resource = function (id) {
    let fields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    return typedef("Resource", v => {
      if (isObj(v)) return {
        type: "Resource",
        value: {
          id: id,
          fields: isArray(fields) ? fields.map((c, i) => ({
            name: v.fields[i].name,
            value: c.value.asArgument(v.fields[i].value)
          })) : v.fields.map(x => ({
            name: x.name,
            value: fields.value.asArgument(x.value)
          }))
        }
      };
      return throwTypeError("Expected Object for type Resource");
    }, v => v);
  };
  const Struct = function (id) {
    let fields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    return typedef("Struct", v => {
      if (isObj(v)) return {
        type: "Struct",
        value: {
          id: id,
          fields: isArray(fields) ? fields.map((c, i) => ({
            name: v.fields[i].name,
            value: c.value.asArgument(v.fields[i].value)
          })) : v.fields.map(x => ({
            name: x.name,
            value: fields.value.asArgument(x.value)
          }))
        }
      };
      return throwTypeError("Expected Object for type Struct");
    }, v => v);
  };
  const Enum = function (id) {
    let fields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    return typedef("Enum", v => {
      if (isObj(v)) return {
        type: "Enum",
        value: {
          id: id,
          fields: isArray(fields) ? fields.map((c, i) => ({
            name: v.fields[i].name,
            value: c.value.asArgument(v.fields[i].value)
          })) : v.fields.map(x => ({
            name: x.name,
            value: fields.value.asArgument(x.value)
          }))
        }
      };
      return throwTypeError("Expected Object for type Enum");
    }, v => v);
  };
  const Path = typedef("Path", v => {
    if (isObj(v)) {
      if (!isString(v.domain)) {
        return throwTypeError(`Expected a string for the Path domain but found ${v.domain}. Find out more about the Path type here: https://docs.onflow.org/cadence/json-cadence-spec/#path`);
      }
      if (!(v.domain === "storage" || v.domain === "private" || v.domain === "public")) {
        return throwTypeError(`Expected either "storage", "private" or "public" as the Path domain but found ${v.domain}. Find out more about the Path type here: https://docs.onflow.org/cadence/json-cadence-spec/#path`);
      }
      if (!isString(v.identifier)) {
        return throwTypeError(`Expected a string for the Path identifier but found ${v.identifier}. Find out more about the Path type here: https://docs.onflow.org/cadence/json-cadence-spec/#path`);
      }
      return {
        type: "Path",
        value: {
          domain: v.domain,
          identifier: v.identifier
        }
      };
    }
    return throwTypeError("Expected Object for type Path");
  }, v => v);

  /**
   * InclusiveRange type
   *
   * @param t - A TypeDescriptor for the type of the range, must be a number (UInt32, Int32, etc.)
   * @returns A TypeDescriptor for an InclusiveRange of the given type
   *
   * @example
   * ```javascript
   * import * as fcl from "@onflow/fcl"
   * import {InclusiveRange, UInt32} from "@onflow/types"
   *
   * const someArg = fcl.arg({start: 1, end: 5, step: 1}, InclusiveRange(UInt32))
   * ```
   */
  const InclusiveRange = t => typedef("InclusiveRange", v => {
    if (isObj(v)) {
      const {
        start,
        end,
        step
      } = v;
      return {
        type: "InclusiveRange",
        value: {
          start: t.asArgument(start),
          end: t.asArgument(end),
          step: t.asArgument(step)
        }
      };
    }
    return throwTypeError("Expected Object for type InclusiveRange");
  }, v => v);

  exports.Address = Address;
  exports.Array = _Array;
  exports.Bool = Bool;
  exports.Character = Character;
  exports.Dictionary = Dictionary;
  exports.Enum = Enum;
  exports.Event = Event;
  exports.Fix64 = Fix64;
  exports.Identity = Identity;
  exports.InclusiveRange = InclusiveRange;
  exports.Int = Int;
  exports.Int128 = Int128;
  exports.Int16 = Int16;
  exports.Int256 = Int256;
  exports.Int32 = Int32;
  exports.Int64 = Int64;
  exports.Int8 = Int8;
  exports.Optional = Optional;
  exports.Path = Path;
  exports.Reference = Reference;
  exports.Resource = Resource;
  exports.String = String;
  exports.Struct = Struct;
  exports.UFix64 = UFix64;
  exports.UInt = UInt;
  exports.UInt128 = UInt128;
  exports.UInt16 = UInt16;
  exports.UInt256 = UInt256;
  exports.UInt32 = UInt32;
  exports.UInt64 = UInt64;
  exports.UInt8 = UInt8;
  exports.Void = Void;
  exports.Word128 = Word128;
  exports.Word16 = Word16;
  exports.Word256 = Word256;
  exports.Word32 = Word32;
  exports.Word64 = Word64;
  exports.Word8 = Word8;
  exports._Array = _Array;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=types.umd.js.map
