'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var fclCore = require('@onflow/fcl-core');
var SignClient = require('@walletconnect/sign-client');
var utilInvariant = require('@onflow/util-invariant');
var utilLogger = require('@onflow/util-logger');
var utils = require('@walletconnect/utils');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var fclCore__namespace = /*#__PURE__*/_interopNamespace(fclCore);
var SignClient__default = /*#__PURE__*/_interopDefaultLegacy(SignClient);

function isAndroid() {
  return typeof navigator !== "undefined" && /android/i.test(navigator.userAgent);
}
function isSmallIOS() {
  return typeof navigator !== "undefined" && /iPhone|iPod/.test(navigator.userAgent);
}
function isLargeIOS() {
  return typeof navigator !== "undefined" && /iPad/.test(navigator.userAgent);
}
function isIOS() {
  return isSmallIOS() || isLargeIOS();
}
function isMobile() {
  return isAndroid() || isIOS();
}

let FLOW_METHODS = /*#__PURE__*/function (FLOW_METHODS) {
  FLOW_METHODS["FLOW_AUTHN"] = "flow_authn";
  FLOW_METHODS["FLOW_PRE_AUTHZ"] = "flow_pre_authz";
  FLOW_METHODS["FLOW_AUTHZ"] = "flow_authz";
  FLOW_METHODS["FLOW_USER_SIGN"] = "flow_user_sign";
  return FLOW_METHODS;
}({});
let REQUEST_TYPES = /*#__PURE__*/function (REQUEST_TYPES) {
  REQUEST_TYPES["SESSION_REQUEST"] = "session_proposal";
  REQUEST_TYPES["SIGNING_REQUEST"] = "signing_request";
  return REQUEST_TYPES;
}({});

const SERVICE_PLUGIN_NAME = "fcl-plugin-service-walletconnect";
const WC_SERVICE_METHOD = "WC/RPC";
const makeServicePlugin = function (client) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    projectId: "",
    includeBaseWC: false,
    wallets: [],
    wcRequestHook: null,
    pairingModalOverride: null
  };
  return {
    name: SERVICE_PLUGIN_NAME,
    f_type: "ServicePlugin",
    type: "discovery-service",
    serviceStrategy: {
      method: WC_SERVICE_METHOD,
      exec: makeExec(client, opts, import('@walletconnect/modal').then(m => m.WalletConnectModal))
    },
    services: []
  };
};
const makeExec = (clientPromise, _ref, WalletConnectModal) => {
  let {
    wcRequestHook,
    pairingModalOverride
  } = _ref;
  return _ref2 => {
    let {
      service,
      body,
      opts
    } = _ref2;
    return new Promise(async (resolve, reject) => {
      const client = await clientPromise;
      utilInvariant.invariant(!!client, "WalletConnect is not initialized");
      let session, pairing, windowRef;
      const method = service.endpoint;
      const appLink = validateAppLink(service);
      const pairings = client.pairing.getAll({
        active: true
      });
      if (pairings.length > 0) {
        pairing = pairings?.find(p => p.peerMetadata?.url === service.uid);
      }
      if (client.session.length > 0) {
        const lastKeyIndex = client.session.keys.length - 1;
        session = client.session.get(client.session.keys.at(lastKeyIndex));
      }
      if (isMobile()) {
        if (opts.windowRef) {
          windowRef = opts.windowRef;
        } else {
          windowRef = window.open("", "_blank");
        }
      }
      if (session == null) {
        session = await connectWc(WalletConnectModal)({
          service,
          onClose,
          appLink,
          windowRef,
          client,
          method,
          pairing,
          wcRequestHook,
          pairingModalOverride
        });
      }
      if (wcRequestHook && wcRequestHook instanceof Function) {
        wcRequestHook({
          type: REQUEST_TYPES.SIGNING_REQUEST,
          method,
          service,
          session: session ?? null,
          pairing: pairing ?? null,
          uri: null
        });
      }
      if (isMobile() && method !== FLOW_METHODS.FLOW_AUTHN) {
        openDeepLink();
      }
      const [chainId, addr, address] = makeSessionData(session);
      const data = JSON.stringify({
        ...body,
        addr,
        address
      });
      try {
        const result = await client.request({
          topic: session.topic,
          chainId,
          request: {
            method,
            params: [data]
          }
        });
        onResponse(result);
      } catch (error) {
        if (error instanceof Error) {
          utilLogger.log({
            title: `${error.name} Error on WalletConnect client ${method} request`,
            message: error.message,
            level: utilLogger.LEVELS.error
          });
        }
        reject(`Declined: Externally Halted`);
      } finally {
        if (windowRef && !windowRef.closed) {
          windowRef.close();
        }
      }
      function validateAppLink(_ref3) {
        let {
          uid
        } = _ref3;
        if (!(uid && /^(ftp|http|https):\/\/[^ "]+$/.test(uid))) {
          utilLogger.log({
            title: "WalletConnect Service Warning",
            message: `service.uid should be a valid universal link url. Found: ${uid}`,
            level: utilLogger.LEVELS.warn
          });
        }
        return uid;
      }
      function openDeepLink() {
        if (windowRef) {
          if (appLink.startsWith("http") && !isIOS()) {
            // Workaround for https://github.com/rainbow-me/rainbowkit/issues/524.
            // Using 'window.open' causes issues on iOS in non-Safari browsers and
            // WebViews where a blank tab is left behind after connecting.
            // This is especially bad in some WebView scenarios (e.g. following a
            // link from Twitter) where the user doesn't have any mechanism for
            // closing the blank tab.
            // For whatever reason, links with a target of "_blank" don't suffer
            // from this problem, and programmatically clicking a detached link
            // element with the same attributes also avoids the issue.
            const link = document.createElement("a");
            link.href = appLink;
            link.target = "_blank";
            link.rel = "noreferrer noopener";
            link.click();
          } else {
            windowRef.location.href = appLink;
          }
        } else {
          utilLogger.log({
            title: "Problem opening deep link in new window",
            message: `Window failed to open (was it blocked by the browser?)`,
            level: utilLogger.LEVELS.warn
          });
        }
      }
      function makeSessionData(session) {
        const [namespace, reference, address] = Object.values(session.namespaces).map(namespace => namespace.accounts).flat().filter(account => account.startsWith("flow:"))[0].split(":");
        const chainId = `${namespace}:${reference}`;
        const addr = address;
        return [chainId, addr, address];
      }
      function onResponse(resp) {
        try {
          if (typeof resp !== "object") return;
          switch (resp.status) {
            case "APPROVED":
              resolve(resp.data);
              break;
            case "DECLINED":
              reject(`Declined: ${resp.reason || "No reason supplied"}`);
              break;
            case "REDIRECT":
              resolve(resp);
              break;
            default:
              reject(`Declined: No reason supplied`);
              break;
          }
        } catch (error) {
          if (error instanceof Error) {
            utilLogger.log({
              title: `${error.name} "WC/RPC onResponse error"`,
              message: error.message,
              level: utilLogger.LEVELS.error
            });
          }
          throw error;
        }
      }
      function onClose() {
        reject(`Declined: Externally Halted`);
      }
    });
  };
};
function connectWc(WalletConnectModal) {
  return async _ref4 => {
    let {
      service,
      onClose,
      appLink,
      windowRef,
      client,
      method,
      pairing,
      wcRequestHook,
      pairingModalOverride
    } = _ref4;
    const network = await fclCore__namespace.getChainId();
    const requiredNamespaces = {
      flow: {
        methods: [FLOW_METHODS.FLOW_AUTHN, FLOW_METHODS.FLOW_PRE_AUTHZ, FLOW_METHODS.FLOW_AUTHZ, FLOW_METHODS.FLOW_USER_SIGN],
        chains: [`flow:${network}`],
        events: ["chainChanged", "accountsChanged"]
      }
    };
    utilInvariant.invariant(!!client.opts?.projectId, "Cannot establish connection, WalletConnect projectId is undefined");
    const projectId = client.opts?.projectId;
    const walletConnectModal = new (await WalletConnectModal)({
      projectId,
      walletConnectVersion: 2
    });
    try {
      const {
        uri,
        approval
      } = await client.connect({
        pairingTopic: pairing?.topic,
        requiredNamespaces
      });
      var _uri = uri;
      if (wcRequestHook && wcRequestHook instanceof Function) {
        wcRequestHook({
          type: REQUEST_TYPES.SESSION_REQUEST,
          method,
          service,
          session: null,
          pairing: pairing ?? null,
          uri: uri ?? null
        });
      }
      utilInvariant.invariant(!!uri, "Cannot establish connection, WalletConnect URI is undefined");
      if (isMobile()) {
        const queryString = new URLSearchParams({
          uri: uri
        }).toString();
        let url = pairing == null ? appLink + "?" + queryString : appLink;
        windowRef.location.href = url;
      } else if (!pairing) {
        if (!pairingModalOverride) {
          walletConnectModal.openModal({
            uri,
            onClose
          });
        } else {
          pairingModalOverride(uri, onClose);
        }
      }
      const session = await approval();
      return session;
    } catch (error) {
      if (error instanceof Error) {
        utilLogger.log({
          title: `${error.name} Error establishing WalletConnect session`,
          message: `
          ${error.message}
          uri: ${_uri}
        `,
          level: utilLogger.LEVELS.error
        });
      }
      onClose();
      throw error;
    } finally {
      if (windowRef && !windowRef.closed) {
        windowRef.close();
      }
      walletConnectModal.closeModal();
    }
  };
}

const DEFAULT_RELAY_URL = "wss://relay.walletconnect.com";
const DEFAULT_LOGGER = "debug";
let clientPromise = Promise.resolve(null);
const initClient = async _ref => {
  let {
    projectId,
    metadata
  } = _ref;
  utilInvariant.invariant(projectId != null, "FCL Wallet Connect Error: WalletConnect projectId is required");
  try {
    return SignClient__default["default"].init({
      logger: DEFAULT_LOGGER,
      relayUrl: DEFAULT_RELAY_URL,
      projectId: projectId,
      metadata: metadata
    });
  } catch (error) {
    if (error instanceof Error) {
      utilLogger.log({
        title: `${error.name} fcl-wc Init Client`,
        message: error.message,
        level: utilLogger.LEVELS.error
      });
    }
    throw error;
  }
};
const initLazy = config => {
  const {
    FclWcServicePlugin,
    clientPromise
  } = initHelper(config);
  fclCore__namespace.discovery.authn.update();
  return {
    FclWcServicePlugin,
    clientPromise
  };
};
const init = async config => {
  const {
    FclWcServicePlugin,
    clientPromise
  } = initLazy(config);
  const client = await clientPromise;
  fclCore__namespace.discovery.authn.update();
  return {
    FclWcServicePlugin,
    client
  };
};
const initHelper = _ref2 => {
  let {
    projectId,
    metadata,
    includeBaseWC = false,
    wcRequestHook = null,
    pairingModalOverride = null,
    wallets = []
  } = _ref2;
  if (typeof window === "undefined") {
    throw new Error("FCL Wallet Connect Plugin can only be initialized in the browser");
  }

  // Lazy load the SignClient
  //  - Initialize the client if it doesn't exist
  //  - If it does exist, return existing client
  //  - If existing client fails to initialize, reinitialize
  clientPromise = Promise.resolve(clientPromise).catch(() => null).then(_client => {
    if (_client) {
      return _client;
    } else {
      return initClient({
        projectId,
        metadata
      });
    }
  }).catch(e => {
    utilLogger.log({
      title: `WalletConnect Client Initialization Error`,
      message: e.message ? e.message : e,
      level: utilLogger.LEVELS.error
    });
    throw e;
  });
  const FclWcServicePlugin = makeServicePlugin(clientPromise, {
    projectId,
    includeBaseWC,
    wcRequestHook,
    pairingModalOverride,
    wallets
  });
  return {
    FclWcServicePlugin,
    clientPromise
  };
};

Object.defineProperty(exports, 'getSdkError', {
  enumerable: true,
  get: function () { return utils.getSdkError; }
});
exports.SERVICE_PLUGIN_NAME = SERVICE_PLUGIN_NAME;
exports.init = init;
exports.initLazy = initLazy;
//# sourceMappingURL=fcl-wc.js.map
