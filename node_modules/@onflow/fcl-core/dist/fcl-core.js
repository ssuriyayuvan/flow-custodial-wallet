'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var sdk = require('@onflow/sdk');
var t = require('@onflow/types');
var utilInvariant = require('@onflow/util-invariant');
var fetchTransport = require('cross-fetch');
var config = require('@onflow/config');
var utilAddress = require('@onflow/util-address');
var logger = require('@onflow/util-logger');
var rlp = require('@onflow/rlp');
var utilActor = require('@onflow/util-actor');
var transportHttp = require('@onflow/transport-http');
var grpcWeb = require('@improbable-eng/grpc-web');
var sha3 = require('sha3');
var utilTemplate = require('@onflow/util-template');
var semver = require('@onflow/util-semver');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var sdk__namespace = /*#__PURE__*/_interopNamespace(sdk);
var t__namespace = /*#__PURE__*/_interopNamespace(t);
var fetchTransport__default = /*#__PURE__*/_interopDefaultLegacy(fetchTransport);
var logger__namespace = /*#__PURE__*/_interopNamespace(logger);
var rlp__namespace = /*#__PURE__*/_interopNamespace(rlp);
var semver__namespace = /*#__PURE__*/_interopNamespace(semver);

const VERSION = "1.10.0" ;

const is = type => d => typeof d === type;
const isRequired = d => d != null;
const isObject = is("object");
const isString = is("string");
const isFunc = is("function");
const isNumber = is("number");

function normalizeArgs(ax) {
  if (isFunc(ax)) return ax(sdk__namespace.arg, t__namespace);
  return [];
}

async function httpDocumentResolver(_ref) {
  let {
    url
  } = _ref;
  utilInvariant.invariant(typeof url !== "undefined", "retrieve({ url }) -- url must be defined");
  let res;
  try {
    res = await fetchTransport__default["default"](url);
  } catch (e) {
    throw new Error("httpDocumentResolver Error: Failed to retrieve document.");
  }
  let document = res.ok ? await res.json() : null;
  return document;
}
const DOCUMENT_RESOLVERS = new Map([["http", httpDocumentResolver], ["https", httpDocumentResolver]]);
async function retrieve(_ref2) {
  let {
    url
  } = _ref2;
  utilInvariant.invariant(typeof url !== "undefined", "retrieve({ url }) -- url must be defined");
  utilInvariant.invariant(typeof url === "string", "retrieve({ url }) -- url must be a string");
  const documentResolversFromConfig = await config.config().where(/^document\.resolver\./);
  Object.keys(documentResolversFromConfig).map(key => {
    const resolverFromConfig = documentResolversFromConfig[key];
    const resolverProtocol = key.replace(/^document\.resolver\./, "");
    DOCUMENT_RESOLVERS.set(resolverProtocol, resolverFromConfig);
  });
  const urlParts = /^(.*):\/\/([A-Za-z0-9\-\.]+)(:[0-9]+)?(.*)$/.exec(url);
  utilInvariant.invariant(urlParts, "Failed to parse URL");
  const protocol = urlParts[1];
  utilInvariant.invariant(urlParts, "Failed to parse URL protocol");
  const resolver = DOCUMENT_RESOLVERS.get(protocol);
  utilInvariant.invariant(resolver, `No resolver found for protcol=${protocol}`);
  let document = await resolver({
    url
  });
  return document;
}

/**
 * @description Fills import addresses in Cadence for network
 *
 * @param {object} params
 * @param {string} params.network - Network to derive Cadence for
 * @param {object} params.template - Interaction Template to derive Cadence from
 * @returns {Promise<string>} - Promise that resolves with the derived Cadence code
 */
async function deriveCadenceByNetwork100(_ref) {
  let {
    network,
    template
  } = _ref;
  utilInvariant.invariant(template.f_version === "1.0.0", "deriveCadenceByNetwork100({ template }) -- template must be version 1.0.0");
  const networkDependencies = Object.keys(template?.data?.dependencies).map(dependencyPlaceholder => {
    const dependencyNetworkContracts = Object.values(template?.data?.dependencies?.[dependencyPlaceholder]);
    utilInvariant.invariant(dependencyNetworkContracts !== undefined, `deriveCadenceByNetwork100 -- Could not find contracts for dependency placeholder: ${dependencyPlaceholder}`);
    utilInvariant.invariant(dependencyNetworkContracts.length > 0, `deriveCadenceByNetwork100 -- Could not find contracts for dependency placeholder: ${dependencyPlaceholder}`);
    const dependencyContract = dependencyNetworkContracts[0];
    const dependencyContractForNetwork = dependencyContract?.[network];
    utilInvariant.invariant(dependencyContractForNetwork, `deriveCadenceByNetwork100 -- Could not find ${network} network information for dependency: ${dependencyPlaceholder}`);
    return [dependencyPlaceholder, dependencyContractForNetwork?.address];
  });
  return networkDependencies.reduce((cadence, _ref2) => {
    let [placeholder, address] = _ref2;
    const regex = new RegExp("(\\b" + placeholder + "\\b)", "g");
    return cadence.replace(regex, address);
  }, template.data.cadence);
}

/**
 * @description - Replaces string imports with the actual contract address
 *
 * @param {object} param
 * @param {string} param.cadence
 * @param {object} param.networkDependencies
 * @returns {string} - Cadence
 */
function replaceStringImports(_ref) {
  let {
    cadence,
    networkDependencies
  } = _ref;
  return Object.keys(networkDependencies).reduce((c, contractName) => {
    const address = networkDependencies[contractName];
    const regex = new RegExp(`import "\\b${contractName}\\b"`, "g");
    return c.replace(regex, `import ${contractName} from ${address}`);
  }, cadence);
}

/**
 * @description Fills import addresses in Cadence for network
 *
 * @param {object} params
 * @param {string} params.network - Network to derive Cadence for
 * @param {object} params.template - Interaction Template to derive Cadence from
 * @returns {Promise<string>} - Promise that resolves with the derived Cadence code
 */
async function deriveCadenceByNetwork110(_ref) {
  let {
    network,
    template
  } = _ref;
  utilInvariant.invariant(template.f_version === "1.1.0", "deriveCadenceByNetwork110({ template }) -- template must be version 1.0.0");

  // get network dependencies from template dependencies, use new string import format
  const networkDependencies = {};
  template?.data?.dependencies.forEach(dependency => {
    dependency.contracts.forEach(contract => {
      const contractName = contract.contract;
      contract.networks.forEach(net => {
        if (net.network === network) {
          networkDependencies[contractName] = net.address;
        }
      });
      utilInvariant.invariant(networkDependencies[contractName] !== undefined, `deriveCadenceByNetwork110 -- Could not find contracts Network Address: ${network} ${contractName}`);
    });
  });
  utilInvariant.invariant(Object.keys(networkDependencies).length === template?.data?.dependencies.length, `deriveCadenceByNetwork110 -- Could not find contracts for import dependencies: ${networkDependencies}`);
  utilInvariant.invariant(Object.keys(networkDependencies).length === Object.values(networkDependencies).length, `deriveCadenceByNetwork110 -- Could not find all addresses for network ${network} dependencies:  ${networkDependencies}`);
  utilInvariant.invariant(template?.data?.cadence?.body, `no cadence found -- Could not replace import dependencies: ${networkDependencies}`);
  return replaceStringImports({
    cadence: template?.data?.cadence?.body,
    networkDependencies
  });
}

/**
 * @description Fills import addresses in Cadence for network
 *
 * @param {object} params
 * @param {string} params.network - Network to derive Cadence for
 * @param {object} params.template - Interaction Template to derive Cadence from
 * @returns {Promise<string>} - Promise that resolves with the derived Cadence code
 */
async function deriveCadenceByNetwork(_ref) {
  let {
    network,
    template
  } = _ref;
  utilInvariant.invariant(network != undefined, "deriveCadenceByNetwork({ network }) -- network must be defined");
  utilInvariant.invariant(typeof network === "string", "deriveCadenceByNetwork({ network }) -- network must be a string");
  utilInvariant.invariant(template != undefined, "deriveCadenceByNetwork({ template }) -- template must be defined");
  utilInvariant.invariant(typeof template === "object", "deriveCadenceByNetwork({ template }) -- template must be an object");
  utilInvariant.invariant(template.f_type === "InteractionTemplate", "deriveCadenceByNetwork({ template }) -- template must be an InteractionTemplate");
  switch (template.f_version) {
    case "1.1.0":
      return await deriveCadenceByNetwork110({
        network,
        template
      });
    case "1.0.0":
      return await deriveCadenceByNetwork100({
        network,
        template
      });
    default:
      throw new Error("deriveCadenceByNetwork Error: Unsupported template version");
  }
}

async function fetchChainId() {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const response = await sdk__namespace.send([sdk__namespace.getNetworkParameters()], opts).then(sdk__namespace.decode);
  return response.chainId;
}

// Cache of chainId promises for each access node value
// key: access node, value: chainId promise
let chainIdCache = {};
let hasWarnedEnv = false;

/**
 * @description
 * Gets the chain ID if its set, otherwise gets the chain ID from the access node
 *
 * @param {object} opts - Optional parameters
 * @returns {Promise<string>} The chain ID of the access node
 * @throws {Error} If the chain ID is not found
 *
 * @example
 * // returns "testnet"
 * getChainId()
 */
async function getChainId() {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let flowNetworkCfg = await config.config.get("flow.network");
  let envCfg = await config.config.get("env");
  if (envCfg && !hasWarnedEnv) {
    logger.log.deprecate({
      pkg: "FCL",
      subject: 'Using the "env" configuration key for specifying the flow network',
      message: "Configuring to specify flow network is no longer required",
      transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/TRANSITIONS.md#0001-deprecate-env-config-key"
    });
    hasWarnedEnv = true;
  }
  const accessNode = opts.node || (await config.config.get("accessNode.api"));
  if (!accessNode) {
    // Fall back to deprecated flow.network and env config keys
    // This probably should have been done before trying to fetch the chainId from the access node
    // However, this was the behaviour with the initial implementation of getChainId()
    if (flowNetworkCfg) {
      return flowNetworkCfg;
    } else if (envCfg) {
      return envCfg;
    }
    throw new Error(`Either the "accessNode.api" config key or opts.node must be set`);
  }

  // Try using cached chainId first if it exists and access node is the same
  if (chainIdCache[accessNode]) {
    try {
      return await chainIdCache[accessNode];
    } catch {}
  }

  // If no cached chainId, value is stale, or last attempt failed, try getting chainId from access node
  // Check if another getChainId() call has already started a new promise, if not, start a new one
  // There may have been concurrent calls to getChainId() while the first call was waiting for the response
  if (!chainIdCache[accessNode]) {
    chainIdCache[accessNode] = fetchChainId(opts).catch(error => {
      // If there was an error, reset the promise so that the next call will try again
      chainIdCache[accessNode] = null;
      throw error;
    });
  }

  // Use newly created promise
  try {
    return await chainIdCache[accessNode];
  } catch (e) {
    // Fall back to deprecated flow.network and env config keys
    // This probably should have been done before trying to fetch the chainId from the access node
    // However, this was the behaviour with the initial implementation of getChainId()
    if (flowNetworkCfg) {
      return flowNetworkCfg;
    } else if (envCfg) {
      return envCfg;
    }
    throw new Error(`Error getting chainId from access node - are you using the correct access node endpoint.  If running locally, is your emulator up-to-date? ${e.message}`);
  }
}

/**
 * @description
 * Watches the config for changes to access node and updates the chain id accordingly
 *
 * @returns {Function} A function that unsubscribes the listener
 *
 */
function watchForChainIdChanges() {
  return config.config.subscribe(() => {
    // Call getChainId to update the chainId cache if access node has changed
    getChainId({
      enableRequestLogging: false
    }).catch(() => {});
  });
}

function isAndroid() {
  return typeof navigator !== "undefined" && /android/i.test(navigator.userAgent);
}
function isSmallIOS() {
  return typeof navigator !== "undefined" && /iPhone|iPod/.test(navigator.userAgent);
}
function isLargeIOS() {
  return typeof navigator !== "undefined" && /iPad/.test(navigator.userAgent);
}
function isIOS() {
  return isSmallIOS() || isLargeIOS();
}
function isMobile() {
  return isAndroid() || isIOS();
}

async function deriveDependencies() {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const template = opts.template;
  const network = await getChainId(opts);
  const derivedDependencies = {};
  switch (template["f_version"]) {
    case "1.0.0":
      const dependencyPlaceholderKeys = Object.keys(template?.data?.dependencies);
      for (let dependencyPlaceholderKey of dependencyPlaceholderKeys) {
        let dependencyPlaceholder = template?.data?.dependencies[dependencyPlaceholderKey];
        const dependencyPlaceholderContractsKeys = Object.keys(dependencyPlaceholder);
        utilInvariant.invariant(dependencyPlaceholderContractsKeys.length > 0, `FCL configureDependencies Error: No contracts found in template for placeholder=${dependencyPlaceholderKey}`);
        const dependencyPlaceholderContract = dependencyPlaceholder[dependencyPlaceholderContractsKeys[0]];
        const dependency = dependencyPlaceholderContract[network];
        utilInvariant.invariant(dependency, `FCL configureDependencies Error: No dependency information for placeholder=${dependencyPlaceholderKey} contract=${dependencyPlaceholderContractsKeys[0]} network=${network}`);
        utilInvariant.invariant(dependency?.address, `FCL configureDependencies Error: No address information for placeholder=${dependencyPlaceholderKey} contract=${dependencyPlaceholderContractsKeys[0]} network=${network}`);
        derivedDependencies[dependencyPlaceholderKey] = utilAddress.withPrefix(dependency?.address);
      }
      return derivedDependencies;
    case "1.1.0":
      template?.data?.dependencies?.forEach(dependency => {
        dependency.contracts.forEach(contract => {
          const contractName = contract.contract;
          contract.networks.forEach(net => {
            if (net.network === network) {
              derivedDependencies[contractName] = utilAddress.withPrefix(net?.address);
            }
          });
          utilInvariant.invariant(derivedDependencies[contractName], `networkAddress -- Could not find contracts Network Address: ${network} ${contractName}`);
        });
      });
      return derivedDependencies;
    default:
      throw new Error("FCL configureDependencies Error: Unsupported template version");
  }
}

async function prepTemplateOpts(opts) {
  if (isString(opts?.template)) {
    opts.template = await retrieve({
      url: opts?.template
    });
  }
  let dependencies = {};
  if (opts?.template) {
    dependencies = await deriveDependencies({
      template: opts.template
    });
  }
  const cadence = opts.cadence || (await deriveCadenceByNetwork({
    template: opts.template,
    network: await getChainId(opts)
  }));
  opts.cadence = cadence;
  opts.dependencies = dependencies;
  return opts;
}

async function pre(type, opts) {
  // prettier-ignore
  utilInvariant.invariant(isRequired(opts), `${type}(opts) -- opts is required`);
  // prettier-ignore
  utilInvariant.invariant(isObject(opts), `${type}(opts) -- opts must be an object`);
  // prettier-ignore
  utilInvariant.invariant(!(opts.cadence && opts.template), `${type}({ template, cadence }) -- cannot pass both cadence and template`);
  // prettier-ignore
  utilInvariant.invariant(isRequired(opts.cadence || opts?.template), `${type}({ cadence }) -- cadence is required`);
  // // prettier-ignore
  utilInvariant.invariant(isString(opts.cadence) || opts?.template, `${type}({ cadence }) -- cadence must be a string`);
  // prettier-ignore
  utilInvariant.invariant(await sdk__namespace.config().get("accessNode.api"), `${type}(opts) -- Required value for "accessNode.api" not defined in config. See: ${"https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/src/exec/query.md#configuration"}`);
}
async function preMutate(opts) {
  return pre("mutate", opts);
}
async function preQuery(opts) {
  return pre("query", opts);
}

/**
 * @description
 * Allows you to submit scripts to query the blockchain.
 *
 *  @param {object} opts - Query Options and configuration
 *  @param {string} opts.cadence - Cadence Script used to query Flow
 *  @param {import("../fcl").ArgsFn} [opts.args] - Arguments passed to cadence script
 *  @param {object | string} [opts.template] - Interaction Template for a script
 *  @param {number} [opts.limit]   - Compute Limit for Query
 *  @returns {Promise}
 *
 *  @example
 *    const cadence = `
 *      cadence: `
 *        access(all) fun main(a: Int, b: Int, c: Address): Int {
 *          log(c)
 *          return a + b
 *        }
 *    `.trim()
 *
 *    const args = (arg, t) => [
 *      arg(5, t.Int),
 *      arg(7, t.Int),
 *      arg("0xb2db43ad6bc345fec9", t.Address),
 *    ]
 *
 *    await query({ cadence, args })
 */
async function query() {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  await preQuery(opts);
  opts = await prepTemplateOpts(opts);
  return sdk__namespace.config().overload(opts.dependencies || {}, async () =>
  // prettier-ignore
  sdk__namespace.send([sdk__namespace.script(opts.cadence), sdk__namespace.args(normalizeArgs(opts.args || [])), opts.limit && typeof opts.limit === "number" && sdk__namespace.limit(opts.limit)]).then(sdk__namespace.decode));
}

const FCL_REDIRECT_URL_PARAM_NAME = "fcl_redirect_url";
const FCL_RESPONSE_PARAM_NAME = "fclResponseJson";
const CORE_STRATEGIES = {
  "HTTP/RPC": "HTTP/RPC",
  "HTTP/POST": "HTTP/POST",
  "IFRAME/RPC": "IFRAME/RPC",
  "POP/RPC": "POP/RPC",
  "TAB/RPC": "TAB/RPC",
  "EXT/RPC": "EXT/RPC",
  "DEEPLINK/RPC": "DEEPLINK/RPC"
};

/**
 * @description
 * Listens for messages from FCL
 *
 * @param {string} messageType - Message type
 * @param {Function} cb - Callback function
 * @returns {Function} - Function to remove event listener
 */
const onMessageFromFCL = function (messageType) {
  let cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};
  const buildData = data => {
    if (data.deprecated) console.warn("DEPRECATION NOTICE", data.deprecated.message);
    delete data?.body?.interaction;
    return data;
  };
  const internal = e => {
    const {
      data
    } = e;
    if (typeof data !== "object") return;
    if (typeof data == null) return;
    if (data.type !== messageType) return;
    cb(buildData(data));
  };
  window.addEventListener("message", internal);
  return () => window.removeEventListener("message", internal);
};

let _isReactNative = false;
function isReactNative() {
  return _isReactNative;
}
function setIsReactNative(value) {
  _isReactNative = value;
}

// This is a workaround for an ongoing issue with URL in React Native
const _URL = globalThis.URL;
class URL extends _URL {
  constructor(url, base) {
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }
    super(url, base, ...args);

    // Extra check if in React Native
    if (!isReactNative()) {
      return;
    }

    // Fix trailing slash issue
    if (this._url && !url.endsWith("/") && this._url.endsWith("/")) {
      this._url = this._url.slice(0, -1);
    }
  }
}

/**
 * @description
 * Sends message to FCL window
 *
 * @param {string} type - Message type
 * @param {object} msg - Message object
 * @returns {void}
 *
 * @example
 * sendMsgToFCL("FCL:VIEW:RESPONSE", {
 *    f_type: "PollingResponse",
 *    f_vsn: "1.0.0",
 *    status: "APPROVED",
 *    reason: null,
 *    data: data,
 *  })
 */
const sendMsgToFCL = function (type) {
  let msg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const data = {
    ...msg,
    type
  };
  const urlParams = new URLSearchParams(window.location.search);
  const redirectUrl = urlParams.get(FCL_REDIRECT_URL_PARAM_NAME);
  if (redirectUrl) {
    const url = new URL(redirectUrl);
    url.searchParams.append(FCL_RESPONSE_PARAM_NAME, JSON.stringify(data));
    window.location.href = url.href;
  } else if (window.location !== window.parent.location) {
    window.parent.postMessage({
      ...msg,
      type
    }, "*");
  } else if (window.opener) {
    window.opener.postMessage({
      ...msg,
      type
    }, "*");
  } else {
    throw new Error("Unable to communicate with parent FCL instance");
  }
};

/**
 * @description
 * Listens for "FCL:VIEW:READY:RESPONSE" and sends "FCL:VIEW:READY"
 *
 * @param {Function} cb - Callback function
 * @param {object} msg - Message object
 * @returns {void}
 */
const ready = function (cb) {
  onMessageFromFCL("FCL:VIEW:READY:RESPONSE", cb);
  sendMsgToFCL("FCL:VIEW:READY");
};

/**
 * @description
 * Sends "FCL:VIEW:CLOSE"
 *
 * @returns {void}
 */
const close = () => {
  sendMsgToFCL("FCL:VIEW:CLOSE");
};

/**
 * @description
 * Sends "FCL:VIEW:RESPONSE" with status "APPROVED"
 *
 * @param {object} data - Data object
 * @returns {void}
 */
const approve = data => {
  sendMsgToFCL("FCL:VIEW:RESPONSE", {
    f_type: "PollingResponse",
    f_vsn: "1.0.0",
    status: "APPROVED",
    reason: null,
    data: data
  });
};

/**
 * @description
 * Sends "FCL:VIEW:RESPONSE" with status "DECLINED"
 *
 * @param {string} reason - Reason for declining
 * @returns {void}
 */
const decline = reason => {
  sendMsgToFCL("FCL:VIEW:RESPONSE", {
    f_type: "PollingResponse",
    f_vsn: "1.0.0",
    status: "DECLINED",
    reason: reason,
    data: null
  });
};

/**
 * @description
 * Sends "FCL:VIEW:RESPONSE" with status "REDIRECT"
 *
 * @param {object} data - Data object
 * @returns {void}
 */
const redirect = data => {
  sendMsgToFCL("FCL:VIEW:RESPONSE", {
    f_type: "PollingResponse",
    f_vsn: "1.0.0",
    status: "REDIRECT",
    reason: null,
    data: data
  });
};

const SERVICE_PRAGMA = {
  f_type: "Service",
  f_vsn: "1.0.0"
};
const IDENTITY_PRAGMA = {
  f_type: "Identity",
  f_vsn: "1.0.0"
};
const USER_PRAGMA = {
  f_type: "USER",
  f_vsn: "1.0.0"
};
const POLLING_RESPONSE_PRAGMA = {
  f_type: "PollingResponse",
  f_vsn: "1.0.0"
};
const COMPOSITE_SIGNATURE_PRAGMA = {
  f_type: "CompositeSignature",
  f_vsn: "1.0.0"
};

/**
 * @description
 * Constructs a new CompositeSignature instance.
 *
 * @param {string} addr - Flow Address
 * @param {number} keyId - Key ID
 * @param {string} signature - Signature as a hex string
 */
function CompositeSignature(addr, keyId, signature) {
  this.f_type = COMPOSITE_SIGNATURE_PRAGMA.f_type;
  this.f_vsn = COMPOSITE_SIGNATURE_PRAGMA.f_vsn;
  this.addr = utilAddress.withPrefix(addr);
  this.keyId = Number(keyId);
  this.signature = signature;
}

const rightPaddedHexBuffer = (value, pad) => rlp.Buffer.from(value.padEnd(pad * 2, "0"), "hex");
const leftPaddedHexBuffer = (value, pad) => rlp.Buffer.from(value.padStart(pad * 2, "0"), "hex");
const addressBuffer = addr => leftPaddedHexBuffer(addr, 8);
const nonceBuffer = nonce => rlp.Buffer.from(nonce, "hex");
const encodeAccountProof = function (_ref) {
  let {
    address,
    nonce,
    appIdentifier
  } = _ref;
  let includeDomainTag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  utilInvariant.invariant(address, "Encode Message For Provable Authn Error: address must be defined");
  utilInvariant.invariant(nonce, "Encode Message For Provable Authn Error: nonce must be defined");
  utilInvariant.invariant(appIdentifier, "Encode Message For Provable Authn Error: appIdentifier must be defined");
  utilInvariant.invariant(nonce.length >= 64, "Encode Message For Provable Authn Error: nonce must be minimum of 32 bytes");
  const ACCOUNT_PROOF_DOMAIN_TAG = rightPaddedHexBuffer(rlp.Buffer.from("FCL-ACCOUNT-PROOF-V0.0").toString("hex"), 32);
  if (includeDomainTag) {
    return rlp.Buffer.concat([ACCOUNT_PROOF_DOMAIN_TAG, rlp.encode([appIdentifier, addressBuffer(utilAddress.sansPrefix(address)), nonceBuffer(nonce)])]).toString("hex");
  }
  return rlp.encode([appIdentifier, addressBuffer(utilAddress.sansPrefix(address)), nonceBuffer(nonce)]).toString("hex");
};

function injectExtService(service) {
  if (service.type === "authn" && service.endpoint != null) {
    if (!Array.isArray(window.fcl_extensions)) {
      window.fcl_extensions = [];
    }
    window.fcl_extensions.push(service);
  } else {
    console.warn("Authn service is required");
  }
}

var index$2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  sendMsgToFCL: sendMsgToFCL,
  ready: ready,
  close: close,
  approve: approve,
  decline: decline,
  redirect: redirect,
  onMessageFromFCL: onMessageFromFCL,
  encodeMessageFromSignable: sdk.encodeMessageFromSignable,
  CompositeSignature: CompositeSignature,
  encodeAccountProof: encodeAccountProof,
  injectExtService: injectExtService
});

const ACCOUNT_PROOF = "ACCOUNT_PROOF";
const USER_SIGNATURE = "USER_SIGNATURE";
const validateArgs = args => {
  if (args.appIdentifier) {
    const {
      appIdentifier,
      address,
      nonce,
      signatures
    } = args;
    utilInvariant.invariant(isString(appIdentifier), "verifyAccountProof({ appIdentifier }) -- appIdentifier must be a string");
    utilInvariant.invariant(isString(address) && utilAddress.sansPrefix(address).length === 16, "verifyAccountProof({ address }) -- address must be a valid address");
    utilInvariant.invariant(/^[0-9a-f]+$/i.test(nonce), "nonce must be a hex string");
    utilInvariant.invariant(Array.isArray(signatures) && signatures.every((sig, i, arr) => sig.f_type === "CompositeSignature"), "Must include an Array of CompositeSignatures to verify");
    utilInvariant.invariant(signatures.map(cs => cs.addr).every((addr, i, arr) => addr === arr[0]), "User signatures to be verified must be from a single account address");
    return true;
  } else {
    const {
      message,
      address,
      compSigs
    } = args;
    utilInvariant.invariant(/^[0-9a-f]+$/i.test(message), "Signed message must be a hex string");
    utilInvariant.invariant(isString(address) && utilAddress.sansPrefix(address).length === 16, "verifyUserSignatures({ address }) -- address must be a valid address");
    utilInvariant.invariant(Array.isArray(compSigs) && compSigs.every((sig, i, arr) => sig.f_type === "CompositeSignature"), "Must include an Array of CompositeSignatures to verify");
    utilInvariant.invariant(compSigs.map(cs => cs.addr).every((addr, i, arr) => addr === arr[0]), "User signatures to be verified must be from a single account address");
    return true;
  }
};

// TODO: pass in option for contract but we're connected to testnet
// log address + network -> in sync?
const getVerifySignaturesScript = async (sig, opts) => {
  const verifyFunction = sig === "ACCOUNT_PROOF" ? "verifyAccountProofSignatures" : "verifyUserSignatures";
  let network = await getChainId(opts);
  const contractAddresses = {
    testnet: "0x74daa6f9c7ef24b1",
    mainnet: "0xb4b82a1c9d21d284",
    previewnet: "0x40b5b8b2ce81ea4a"
  };
  const fclCryptoContract = opts.fclCryptoContract || contractAddresses[network];
  utilInvariant.invariant(fclCryptoContract, `${verifyFunction}({ fclCryptoContract }) -- FCLCrypto contract address is unknown for network: ${network}. Please manually specify the FCLCrypto contract address.`);
  return `
      import FCLCrypto from ${fclCryptoContract}

      access(all) fun main(
          address: Address, 
          message: String, 
          keyIndices: [Int], 
          signatures: [String]
      ): Bool {
        return FCLCrypto.${verifyFunction}(address: address, message: message, keyIndices: keyIndices, signatures: signatures)
      }
    `;
};

/**
 * @description
 * Verify a valid account proof signature or signatures for an account on Flow.
 *
 * @param {string} appIdentifier - A message string in hexadecimal format
 * @param {object} accountProofData - An object consisting of address, nonce, and signatures
 * @param {string} accountProofData.address - A Flow account address
 * @param {string} accountProofData.nonce - A random string in hexadecimal format (minimum 32 bytes in total, i.e 64 hex characters)
 * @param {object[]} accountProofData.signatures - An array of composite signatures to verify
 * @param {object} [opts={}] - Options object
 * @param {string} opts.fclCryptoContract - An optional override Flow account address where the FCLCrypto contract is deployed
 * @returns {Promise<boolean>} - Returns true if the signature is valid, false otherwise
 *
 * @example
 *
 *  const accountProofData = {
 *   address: "0x123",
 *   nonce: "F0123"
 *   signatures: [{f_type: "CompositeSignature", f_vsn: "1.0.0", addr: "0x123", keyId: 0, signature: "abc123"}],
 *  }
 *
 *  const isValid = await fcl.AppUtils.verifyAccountProof(
 *    "AwesomeAppId",
 *    accountProofData,
 *    {fclCryptoContract}
 *  )
 */
async function verifyAccountProof(appIdentifier, _ref) {
  let {
    address,
    nonce,
    signatures
  } = _ref;
  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  validateArgs({
    appIdentifier,
    address,
    nonce,
    signatures
  });
  const message = encodeAccountProof({
    address,
    nonce,
    appIdentifier
  }, false);
  let signaturesArr = [];
  let keyIndices = [];
  for (const el of signatures) {
    signaturesArr.push(el.signature);
    keyIndices.push(el.keyId.toString());
  }
  return query({
    cadence: await getVerifySignaturesScript(ACCOUNT_PROOF, opts),
    args: (arg, t) => [arg(utilAddress.withPrefix(address), t.Address), arg(message, t.String), arg(keyIndices, t.Array(t.Int)), arg(signaturesArr, t.Array(t.String))]
  });
}

/**
 * @description
 * Verify a valid signature/s for an account on Flow.
 *
 * @param {string} message - A message string in hexadecimal format
 * @param {Array} compSigs - An array of Composite Signatures
 * @param {string} compSigs[].addr - The account address
 * @param {number} compSigs[].keyId - The account keyId
 * @param {string} compSigs[].signature - The signature to verify
 * @param {object} [opts={}] - Options object
 * @param {string} opts.fclCryptoContract - An optional override of Flow account address where the FCLCrypto contract is deployed
 * @returns {boolean} - Returns true if the signature is valid, false otherwise
 *
 * @example
 *
 *  const isValid = await fcl.AppUtils.verifyUserSignatures(
 *    Buffer.from('FOO').toString("hex"),
 *    [{f_type: "CompositeSignature", f_vsn: "1.0.0", addr: "0x123", keyId: 0, signature: "abc123"}],
 *    {fclCryptoContract}
 *  )
 */
async function verifyUserSignatures$1(message, compSigs) {
  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const address = utilAddress.withPrefix(compSigs[0].addr);
  validateArgs({
    message,
    address,
    compSigs
  });
  let signaturesArr = [];
  let keyIndices = [];
  for (const el of compSigs) {
    signaturesArr.push(el.signature);
    keyIndices.push(el.keyId.toString());
  }
  return query({
    cadence: await getVerifySignaturesScript(USER_SIGNATURE, opts),
    args: (arg, t) => [arg(address, t.Address), arg(message, t.String), arg(keyIndices, t.Array(t.Int)), arg(signaturesArr, t.Array(t.String))]
  });
}

var index$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  verifyAccountProof: verifyAccountProof,
  verifyUserSignatures: verifyUserSignatures$1
});

/**
 * Verify a valid signature/s for an account on Flow.
 *
 * @deprecated since version '1.0.0-alpha.0', use AppUtils.verifyUserSignatures instead
 *
 */
const verifyUserSignatures = logger.log.deprecate({
  pkg: "FCL",
  subject: "fcl.verifyUserSignatures()",
  message: "Please use fcl.AppUtils.verifyUserSignatures()",
  callback: function verifyUserSignatures(message, compSigs) {
    return verifyUserSignatures$1(message, compSigs);
  }
});

const serialize = async function () {
  let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const resolveFunction = await sdk.config.first(["sdk.resolve"], opts.resolve || sdk.resolve);
  if (Array.isArray(args)) args = await sdk.pipe(sdk.interaction(), args);
  return JSON.stringify(sdk.createSignableVoucher(await resolveFunction(args)), null, 2);
};

async function configLens(regex) {
  return Object.fromEntries(Object.entries(await config.config().where(regex)).map(_ref => {
    let [key, value] = _ref;
    return [key.replace(regex, ""), value];
  }));
}

const TXID_REGEXP = /^[0-9a-fA-F]{64}$/;

/**
 * @typedef {import("@onflow/typedefs").Transaction} Transaction
 */

/**
 * @typedef {import("@onflow/typedefs").TransactionStatus} TransactionStatus
 */

const POLL = "POLL";
const TIMEOUT = "TIMEOUT";
const fetchTxStatus = async transactionId => {
  return sdk.send([sdk.getTransactionStatus(transactionId)]).then(sdk.decode);
};
const isExpired = tx => tx.status === 5;
const isSealed = tx => tx.status >= 4;
const isExecuted = tx => tx.status >= 3;
const isFinalized = tx => tx.status >= 2;
const isPending = tx => tx.status >= 1;
const isUnknown = tx => tx.status >= 0;
const isDiff = (cur, next) => {
  return JSON.stringify(cur) !== JSON.stringify(next);
};
const makeHandlers = function () {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return {
    [utilActor.INIT]: async ctx => {
      setTimeout(() => ctx.sendSelf(TIMEOUT), opts.txNotFoundTimeout);
      ctx.sendSelf(POLL);
    },
    [utilActor.SUBSCRIBE]: (ctx, letter) => {
      ctx.subscribe(letter.from);
      ctx.send(letter.from, utilActor.UPDATED, ctx.all());
    },
    [utilActor.UNSUBSCRIBE]: (ctx, letter) => {
      ctx.unsubscribe(letter.from);
    },
    [utilActor.SNAPSHOT]: async (ctx, letter) => {
      letter.reply(ctx.all());
    },
    [TIMEOUT]: async ctx => {
      // If status is still unknown, send a timeout error
      if (Object.keys(ctx.all()).length === 0) {
        ctx.fatalError(new Error(`TX status polling failed: no transaction was found within timeout interval (${opts.txNotFoundTimeout}ms)`));
      }
    },
    [POLL]: async ctx => {
      // Helper to queue another poll
      const poll = () => setTimeout(() => ctx.sendSelf(POLL), opts.pollRate);
      let tx;
      const prevTx = ctx.all();
      try {
        tx = await fetchTxStatus(ctx.self());
      } catch (e) {
        const isHttpNotFound = e instanceof transportHttp.HTTPRequestError && e.statusCode === 404;
        const isGrpcNotFound = e.code === grpcWeb.grpc.Code.NotFound;

        // If TX is not found, suppress error and poll again
        if (isHttpNotFound || isGrpcNotFound) {
          return poll();
        }
        return ctx.fatalError(e);
      }
      if (!isSealed(tx)) poll();
      if (isDiff(prevTx, tx)) ctx.broadcast(utilActor.UPDATED, tx);
      ctx.merge(tx);
    }
  };
};
const scoped = transactionId => {
  if (typeof transactionId === "object") transactionId = transactionId.transactionId;
  if (transactionId == null) throw new Error("transactionId required");
  return transactionId;
};
const spawnTransaction = function () {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return transactionId => {
    return utilActor.spawn(makeHandlers(opts), scoped(transactionId));
  };
};

/**
 * @callback SubscriptionCallback
 * @param {TransactionStatus} txStatus
 * @returns {void}
 */

/**
 * Provides methods for interacting with a transaction
 *
 * @param {string} transactionId - The transaction ID
 * @param {object} [opts] - Optional parameters
 * @param {number} [opts.pollRate=2500] - Polling rate in milliseconds
 * @param {number} [opts.txNotFoundTimeout=12500] - Timeout in milliseconds for ignoring transaction not found errors (do not modify unless you know what you are doing)
 * @returns {{
 *    snapshot: function(): Promise<TransactionStatus>,
 *    subscribe: function(SubscriptionCallback): function(): void,
 *    onceFinalized: function(): Promise<TransactionStatus>,
 *    onceExecuted: function(): Promise<TransactionStatus>,
 *    onceSealed: function(): Promise<TransactionStatus>
 * }}
 * @throws {Error} If transactionId is not a 64 byte hash string
 */
function transaction(transactionId) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    txNotFoundTimeout: 12500,
    pollRate: 2500
  };
  // Validate transactionId as 64 byte hash
  if (!TXID_REGEXP.test(scoped(transactionId))) throw new Error("Invalid transactionId");
  function snapshot() {
    return utilActor.snapshoter(transactionId, spawnTransaction(opts));
  }
  function subscribe(callback) {
    return utilActor.subscriber(scoped(transactionId), spawnTransaction(opts), callback);
  }
  function once(predicate) {
    return function innerOnce() {
      let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      const suppress = opts.suppress || false;
      return new Promise((resolve, reject) => {
        const unsub = subscribe((txStatus, error) => {
          if ((error || txStatus.statusCode) && !suppress) {
            reject(error || txStatus.errorMessage);
            unsub();
          } else if (predicate(txStatus)) {
            resolve(txStatus);
            unsub();
          }
        });
      });
    };
  }
  return {
    snapshot,
    subscribe,
    onceFinalized: once(isFinalized),
    onceExecuted: once(isExecuted),
    onceSealed: once(isSealed)
  };
}
transaction.isUnknown = isUnknown;
transaction.isPending = isPending;
transaction.isFinalized = isFinalized;
transaction.isExecuted = isExecuted;
transaction.isSealed = isSealed;
transaction.isExpired = isExpired;

const RATE = 10000;
const UPDATED$1 = "UPDATED";
const TICK = "TICK";
const HIGH_WATER_MARK = "hwm";
const scheduleTick = async ctx => {
  return setTimeout(() => ctx.sendSelf(TICK), await sdk.config().get("fcl.eventPollRate", RATE));
};
const HANDLERS$2 = {
  [TICK]: async ctx => {
    if (!ctx.hasSubs()) return;
    let hwm = ctx.get(HIGH_WATER_MARK);
    if (hwm == null) {
      ctx.put(HIGH_WATER_MARK, await sdk.block());
      ctx.put(TICK, await scheduleTick(ctx));
    } else {
      let next = await sdk.block();
      ctx.put(HIGH_WATER_MARK, next);
      if (hwm.height < next.height) {
        const data = await sdk.send([sdk.getEventsAtBlockHeightRange(ctx.self(), hwm.height + 1, next.height)]).then(sdk.decode);
        for (let d of data) ctx.broadcast(UPDATED$1, d.data);
      }
      ctx.put(TICK, await scheduleTick(ctx));
    }
  },
  [utilActor.SUBSCRIBE]: async (ctx, letter) => {
    if (!ctx.hasSubs()) {
      ctx.put(TICK, await scheduleTick(ctx));
    }
    ctx.subscribe(letter.from);
  },
  [utilActor.UNSUBSCRIBE]: (ctx, letter) => {
    ctx.unsubscribe(letter.from);
    if (!ctx.hasSubs()) {
      clearTimeout(ctx.get(TICK));
      ctx.delete(TICK);
      ctx.delete(HIGH_WATER_MARK);
    }
  }
};
const spawnEvents = key => utilActor.spawn(HANDLERS$2, key);

/**
 * @typedef {import("@onflow/typedefs").Event} Event
 */

/**
 * @typedef {object} SubscribeObject
 * @property {Function} subscribe - The subscribe function.
 */

/**
 * @callback SubscriptionCallback
 * @returns {Event}
 */

/**
 * @description - Subscribe to events
 * @param {string} key - A valid event name
 * @returns {SubscribeObject}
 *
 * @example
 * import * as fcl from "@onflow/fcl"
 * fcl.events(eventName).subscribe((event) => console.log(event))
 */
function events$1(key) {
  return {
    /**
     * @description - Subscribe to events
     * @param {Function} callback - The callback function
     * @returns {SubscriptionCallback}
     */
    subscribe: callback => utilActor.subscriber(key, spawnEvents, callback)
  };
}

/**
 * @description - Subscribe to events
 * @param filterOrType - The filter or type of events to subscribe to
 *
 * @example
 * import * as fcl from "@onflow/fcl"
 * const unsubscribe = fcl.events(eventName).subscribe((event) => console.log(event))
 * unsubscribe()
 */
function events(filterOrType) {
  let filter;
  if (typeof filterOrType === "string") {
    filter = {
      eventTypes: [filterOrType]
    };
  } else {
    filter = filterOrType || {};
  }
  return {
    subscribe: callback => {
      const streamPromise = sdk.send([sdk.subscribeEvents(filter)]).then(sdk.decode);

      // If the subscribe fails, fallback to legacy events
      const legacySubscriptionPromise = streamPromise.then(() => null).catch(e => {
        // Only fallback to legacy events if the error is specifcally about the unsupported feature
        if (e.message !== "SDK Send Error: subscribeEvents is not supported by this transport.") {
          throw e;
        }
        if (typeof filterOrType !== "string") {
          throw new Error("GRPC fcl.events fallback only supports string (type) filters");
        }
        return events$1(filterOrType).subscribe(callback);
      });

      // Subscribe to the stream using the callback
      function onEvents(data) {
        data.forEach(event => callback(event, null));
      }
      function onError(error) {
        callback(null, error);
      }

      // If using legacy events, don't subscribe to the stream
      legacySubscriptionPromise.then(legacySubscription => {
        if (!legacySubscription) {
          streamPromise.then(stream => stream.on("events", onEvents).on("error", onError)).catch(error => {
            streamPromise.then(stream => stream.close());
            onError(error);
          });
        }
      });

      // Unsubscribe will call terminate the legacy subscription or close the stream
      return () => {
        legacySubscriptionPromise.then(legacySubscription => {
          if (legacySubscription) {
            legacySubscription();
          } else {
            streamPromise.then(stream => stream.close());
          }
        });
      };
    }
  };
}

const stub = () => {
  throw new Error(`Platform specific Core Strategies are not initialized`);
};
const stubCoreStrategies = {
  [CORE_STRATEGIES["EXT/RPC"]]: stub,
  [CORE_STRATEGIES["HTTP/POST"]]: stub,
  [CORE_STRATEGIES["IFRAME/RPC"]]: stub,
  [CORE_STRATEGIES["POP/RPC"]]: stub,
  [CORE_STRATEGIES["TAB/RPC"]]: stub,
  [CORE_STRATEGIES["EXT/RPC"]]: stub
};
const supportedPlugins = ["ServicePlugin"];
const supportedServicePlugins = ["discovery-service"];
const validateDiscoveryPlugin = servicePlugin => {
  const {
    services = [],
    serviceStrategy
  } = servicePlugin;
  utilInvariant.invariant(Array.isArray(services), "Services must be an array");
  for (const ds of services) {
    utilInvariant.invariant(isRequired(ds.f_type) && ds.f_type === "Service", "Service is required");
    utilInvariant.invariant(isRequired(ds.type) && ds.type === "authn", `Service must be type authn. Received ${ds.type}`);
    utilInvariant.invariant(ds.method in CORE_STRATEGIES || serviceStrategy.method === ds.method, `Service method ${ds.method} is not supported`);
  }
  utilInvariant.invariant(isRequired(serviceStrategy), "Service strategy is required");
  utilInvariant.invariant(isRequired(serviceStrategy.method) && isString(serviceStrategy.method), "Service strategy method is required");
  utilInvariant.invariant(isRequired(serviceStrategy.exec) && isFunc(serviceStrategy.exec), "Service strategy exec function is required");
  return {
    discoveryServices: services,
    serviceStrategy
  };
};
const ServiceRegistry = _ref => {
  let {
    coreStrategies
  } = _ref;
  let services = new Set();
  let strategies = new Map(Object.entries(coreStrategies));
  const add = servicePlugin => {
    utilInvariant.invariant(supportedServicePlugins.includes(servicePlugin.type), `Service Plugin type ${servicePlugin.type} is not supported`);
    if (servicePlugin.type === "discovery-service") {
      const {
        discoveryServices,
        serviceStrategy
      } = validateDiscoveryPlugin(servicePlugin);
      setServices(discoveryServices);
      if (!strategies.has(serviceStrategy.method)) {
        strategies.set(serviceStrategy.method, serviceStrategy.exec);
      } else {
        logger.log({
          title: `Add Service Plugin`,
          message: `Service strategy for ${serviceStrategy.method} already exists`,
          level: logger.LEVELS.warn
        });
      }
    }
  };
  const setServices = discoveryServices => services = new Set([...discoveryServices]);
  const getServices = () => [...services];
  const getStrategy = method => strategies.get(method);
  const getStrategies = () => [...strategies.keys()];
  return Object.freeze({
    add,
    getServices,
    getStrategy,
    getStrategies
  });
};
const validatePlugins = plugins => {
  let pluginsArray;
  utilInvariant.invariant(!!plugins, "No plugins supplied");
  if (!Array.isArray(plugins)) {
    pluginsArray = [plugins];
  } else {
    pluginsArray = [...plugins];
  }
  for (const p of pluginsArray) {
    utilInvariant.invariant(isRequired(p.name), "Plugin name is required");
    utilInvariant.invariant(isRequired(p.f_type), "Plugin f_type is required");
    utilInvariant.invariant(supportedPlugins.includes(p.f_type), `Plugin type ${p.f_type} is not supported`);
  }
  return pluginsArray;
};
const PluginRegistry = () => {
  const pluginsMap = new Map();
  const getPlugins = () => pluginsMap;
  const add = plugins => {
    const pluginsArray = validatePlugins(plugins);
    for (const p of pluginsArray) {
      pluginsMap.set(p.name, p);
      if (p.f_type === "ServicePlugin") {
        serviceRegistry.add(p);
      }
    }
  };
  return Object.freeze({
    add,
    getPlugins
  });
};
let serviceRegistry;
const getIsServiceRegistryInitialized = () => typeof serviceRegistry !== "undefined";
const initServiceRegistry = _ref2 => {
  let {
    coreStrategies
  } = _ref2;
  if (getIsServiceRegistryInitialized()) {
    return serviceRegistry;
  }
  const _serviceRegistry = ServiceRegistry({
    coreStrategies
  });
  serviceRegistry = _serviceRegistry;
  return _serviceRegistry;
};
const getServiceRegistry = () => {
  if (!getIsServiceRegistryInitialized()) {
    console.warn("Registry is not initalized, it will be initialized with stub core strategies");
    return initServiceRegistry({
      coreStrategies: stubCoreStrategies
    });
  }
  return serviceRegistry;
};
const pluginRegistry = PluginRegistry();

const makeDiscoveryServices = async () => {
  const extensionServices = window?.fcl_extensions || [];
  return [...extensionServices, ...getServiceRegistry().getServices()];
};
async function getDiscoveryService(service) {
  const discoveryAuthnInclude = await config.config.get("discovery.authn.include", []);
  const discoveryFeaturesSuggested = await config.config.get("discovery.features.suggested", []);
  const discoveryWalletMethod = await config.config.first(["discovery.wallet.method", "discovery.wallet.method.default"]);
  const method = service?.method ? service.method : discoveryWalletMethod;
  const endpoint = service?.endpoint ?? (await config.config.first(["discovery.wallet", "challenge.handshake"]));
  utilInvariant.invariant(endpoint, `
    If no service is passed to "authenticate," then "discovery.wallet" must be defined in fcl config.
    See: "https://docs.onflow.org/fcl/reference/api/#setting-configuration-values"
    `);
  return {
    ...service,
    type: "authn",
    endpoint,
    method,
    discoveryAuthnInclude,
    discoveryFeaturesSuggested
  };
}

async function getServices(_ref) {
  let {
    types
  } = _ref;
  const endpoint = await config.config.get("discovery.authn.endpoint");
  utilInvariant.invariant(Boolean(endpoint), `"discovery.authn.endpoint" in config must be defined.`);
  const include = await config.config.get("discovery.authn.include", []);
  const url = new URL(endpoint);
  return fetch(url, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      type: types,
      fclVersion: VERSION,
      include,
      features: {
        suggested: await config.config.get("discovery.features.suggested", [])
      },
      clientServices: await makeDiscoveryServices(),
      supportedStrategies: getServiceRegistry().getStrategies(),
      userAgent: window?.navigator?.userAgent,
      network: await getChainId()
    })
  }).then(d => d.json());
}

const SERVICE_ACTOR_KEYS = {
  AUTHN: "authn",
  RESULTS: "results",
  SNAPSHOT: "SNAPSHOT",
  UPDATED: "UPDATED",
  UPDATE_RESULTS: "UPDATE_RESULTS"
};
const warn = (fact, msg) => {
  if (fact) {
    console.warn(`
      %cFCL Warning
      ============================
      ${msg}
      For more info, please see the docs: https://docs.onflow.org/fcl/
      ============================
      `, "font-weight:bold;font-family:monospace;");
  }
};
const fetchServicesFromDiscovery = async () => {
  try {
    const services = await getServices({
      types: [SERVICE_ACTOR_KEYS.AUTHN]
    });
    utilActor.send(SERVICE_ACTOR_KEYS.AUTHN, SERVICE_ACTOR_KEYS.UPDATE_RESULTS, {
      results: services
    });
  } catch (error) {
    logger.log({
      title: `${error.name} Error fetching Discovery API services.`,
      message: error.message,
      level: logger.LEVELS.error
    });
  }
};
const HANDLERS$1 = {
  [utilActor.INIT]: async ctx => {
    warn(typeof window === "undefined", '"fcl.discovery" is only available in the browser.');
    // If you call this before the window is loaded extensions will not be set yet
    if (document.readyState === "complete") {
      fetchServicesFromDiscovery();
    } else {
      window.onload = async () => {
        fetchServicesFromDiscovery();
      };
    }
  },
  [SERVICE_ACTOR_KEYS.UPDATE_RESULTS]: (ctx, _letter, data) => {
    ctx.merge(data);
    ctx.broadcast(SERVICE_ACTOR_KEYS.UPDATED, {
      ...ctx.all()
    });
  },
  [utilActor.SUBSCRIBE]: (ctx, letter) => {
    ctx.subscribe(letter.from);
    ctx.send(letter.from, SERVICE_ACTOR_KEYS.UPDATED, {
      ...ctx.all()
    });
  },
  [utilActor.UNSUBSCRIBE]: (ctx, letter) => ctx.unsubscribe(letter.from),
  [SERVICE_ACTOR_KEYS.SNAPSHOT]: async (ctx, letter) => letter.reply({
    ...ctx.all()
  })
};
const spawnProviders = () => utilActor.spawn(HANDLERS$1, SERVICE_ACTOR_KEYS.AUTHN);

/**
 * @typedef {import("@onflow/typedefs").Service} Service
 */

/**
 * @callback SubscriptionCallback
 * @returns {Service[]}
 */

/**
 * @description
 * Discovery methods for interacting with Authn.
 *
 * @typedef {object} Authn
 * @property {Function} subscribe - Subscribe to Discovery authn services
 * @property {Function} snapshot - Get the current Discovery authn services spanshot
 * @property {Function} update - Trigger an update of authn services
 */
const authn = {
  /**
   * @description - Subscribe to Discovery authn services
   * @param {Function} cb
   * @returns {SubscriptionCallback}
   */
  subscribe: cb => utilActor.subscriber(SERVICE_ACTOR_KEYS.AUTHN, spawnProviders, cb),
  /**
   * @description - Get the current Discovery authn services spanshot
   * @returns {Service[]}
   */
  snapshot: () => utilActor.snapshoter(SERVICE_ACTOR_KEYS.AUTHN, spawnProviders),
  /**
   * @description - Trigger an update of authn services
   * @returns {void}
   */
  update: () => fetchServicesFromDiscovery()
};

const discovery = {
  authn
};

function genHash(utf8String) {
  const sha = new sha3.SHA3(256);
  sha.update(rlp.Buffer.from(utf8String, "utf8"));
  return sha.digest("hex");
}

/**
 * @description Generates Interaction Template ID for a given Interaction Template
 *
 * @param {object} params
 * @param {object} params.template - Interaction Template
 * @returns {Promise<string>} - Interaction Template ID
 */
async function generateTemplateId$2(_ref) {
  let {
    template
  } = _ref;
  sdk.invariant(template != undefined, "generateTemplateId({ template }) -- template must be defined");
  sdk.invariant(typeof template === "object", "generateTemplateId({ template }) -- template must be an object");
  sdk.invariant(template.f_type === "InteractionTemplate", "generateTemplateId({ template }) -- template object must be an InteractionTemplate");
  sdk.invariant(template.f_version === "1.0.0", "generateTemplateId({ template }) -- template object must be an version 1.0.0");
  const templateData = template.data;
  const messages = await Promise.all(Object.keys(templateData.messages).map(async messageKey => [genHash(messageKey), await Promise.all(Object.keys(templateData.messages?.[messageKey]?.i18n).map(async i18nkeylanguage => [genHash(i18nkeylanguage), genHash(templateData.messages?.[messageKey]?.i18n?.[i18nkeylanguage])]))]));
  const dependencies = await Promise.all(Object.keys(templateData?.dependencies).map(async dependencyAddressPlaceholder => [genHash(dependencyAddressPlaceholder), await Promise.all(Object.keys(templateData?.dependencies?.[dependencyAddressPlaceholder]).map(async dependencyContract => [genHash(dependencyContract), await Promise.all(Object.keys(templateData?.dependencies?.[dependencyAddressPlaceholder]?.[dependencyContract]).map(async dependencyContractNetwork => [genHash(dependencyContractNetwork), [genHash(templateData?.dependencies?.[dependencyAddressPlaceholder]?.[dependencyContract]?.[dependencyContractNetwork].address), genHash(templateData?.dependencies?.[dependencyAddressPlaceholder]?.[dependencyContract]?.[dependencyContractNetwork].contract), genHash(templateData?.dependencies?.[dependencyAddressPlaceholder]?.[dependencyContract]?.[dependencyContractNetwork].fq_address), genHash(templateData?.dependencies?.[dependencyAddressPlaceholder]?.[dependencyContract]?.[dependencyContractNetwork].pin), genHash(String(templateData?.dependencies?.[dependencyAddressPlaceholder]?.[dependencyContract]?.[dependencyContractNetwork].pin_block_height))]]))]))]));
  const _arguments = await Promise.all(Object.keys(templateData?.["arguments"]).map(async argumentLabel => [genHash(argumentLabel), [genHash(String(templateData?.["arguments"]?.[argumentLabel].index)), genHash(templateData?.["arguments"]?.[argumentLabel].type), genHash(templateData?.["arguments"]?.[argumentLabel].balance || ""), await Promise.all(Object.keys(templateData?.["arguments"]?.[argumentLabel].messages).map(async argumentMessageKey => [genHash(argumentMessageKey), await Promise.all(Object.keys(templateData?.["arguments"]?.[argumentLabel].messages?.[argumentMessageKey].i18n).map(async i18nkeylanguage => [genHash(i18nkeylanguage), genHash(templateData?.["arguments"]?.[argumentLabel].messages?.[argumentMessageKey].i18n?.[i18nkeylanguage])]))]))]]));
  const encodedHex = rlp.encode([genHash("InteractionTemplate"), genHash("1.0.0"), genHash(templateData?.type), genHash(templateData?.interface), messages, genHash(templateData?.cadence), dependencies, _arguments]).toString("hex");
  return genHash(encodedHex);
}

function generateImport(_ref) {
  let {
    contractName,
    address
  } = _ref;
  return {
    contractName,
    address,
    contract: ""
  };
}

function findImports(cadence) {
  const imports = [];
  const importsReg = /import ((\w|,| )+)* from 0x\w+/g;
  const fileImports = cadence.match(importsReg) || [];
  for (const fileImport of fileImports) {
    const importLineReg = /import ((\w+|, |)*) from (0x\w+)/g;
    const importLine = importLineReg.exec(fileImport);
    const contractsReg = /((?:\w+)+),?/g;
    const contracts = importLine[1].match(contractsReg) || [];
    for (const contract of contracts) {
      imports.push(generateImport({
        address: importLine[3],
        contractName: contract.replace(/,/g, "")
      }));
    }
  }
  return imports;
}

/**
 * @description Produces a dependency pin for a contract at current state of chain
 * @param {object} params
 * @param {string} params.address - The address of the account containing the contract
 * @param {string} params.contractName - The name of the contract
 * @param {object} opts - Options to pass to the interaction
 * @returns {Promise<string>} - The dependency pin
 */
async function generateDependencyPin110(_ref) {
  let {
    address,
    contractName
  } = _ref;
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  sdk.invariant(address != undefined, "generateDependencyPin({ address }) -- address must be defined");
  sdk.invariant(contractName != undefined, "generateDependencyPin({ contractName }) -- contractName must be defined");
  sdk.invariant(typeof address === "string", "generateDependencyPin({ address }) -- address must be a string");
  sdk.invariant(typeof contractName === "string", "generateDependencyPin({ contractName }) -- contractName must be a string");
  const horizon = [generateImport({
    contractName,
    address
  })];
  for (const horizonImport of horizon) {
    const account = await sdk.send([sdk.getAccount(await sdk.config().get(horizonImport.address, horizonImport.address))], opts).then(sdk.decode);
    horizonImport.contract = account.contracts?.[horizonImport.contractName];
    if (!horizonImport.contract) {
      console.error("Did not find expected contract", horizonImport, account);
      throw new Error("Did not find expected contract");
    }
    const contractImports = findImports(horizonImport.contract);
    horizon.push(...contractImports);
  }
  const contractPinSelfHashesPromises = horizon.map(iport => genHash(iport.contract));
  // genHash returns a promise, so we need to await the results of all the promises
  const contractPinSelfHashes = await Promise.all(contractPinSelfHashesPromises);
  const contractPinHashes = contractPinSelfHashes.join("");
  return genHash(contractPinHashes);
}

async function generateContractNetworks(contractName, networks) {
  const values = [];
  for (const net of networks) {
    const networkHashes = [genHash(net.network)];
    const {
      address,
      dependency_pin_block_height
    } = net;
    if (net.dependency_pin) {
      const hash = await generateDependencyPin110({
        address,
        contractName,
        blockHeight: dependency_pin_block_height
      });
      networkHashes.push(genHash(hash));
    }
    values.push(networkHashes);
  }
  return values;
}
async function generateContractDependencies(dependencies) {
  const values = [];
  for (let i = 0; i < dependencies.length; i++) {
    const dependency = dependencies[i];
    const contracts = [];
    for (let j = 0; j < dependency?.contracts.length; j++) {
      const c = dependency?.contracts[j];
      const contractName = c?.contract;
      contracts.push(genHash(contractName));
      const contractHashes = await generateContractNetworks(contractName, c?.networks);
      contracts.push(contractHashes);
    }
    values.push(contracts);
  }
  return values;
}

/**
 * @description Generates Interaction Template ID for a given Interaction Template
 *
 * @param {object} params
 * @param {object} params.template - Interaction Template
 * @returns {Promise<string>} - Interaction Template ID
 */
async function generateTemplateId$1(_ref) {
  let {
    template
  } = _ref;
  utilInvariant.invariant(template, "generateTemplateId({ template }) -- template must be defined");
  utilInvariant.invariant(typeof template === "object", "generateTemplateId({ template }) -- template must be an object");
  utilInvariant.invariant(template.f_type === "InteractionTemplate", "generateTemplateId({ template }) -- template object must be an InteractionTemplate");
  utilInvariant.invariant(template.f_version === "1.1.0", "generateTemplateId({ template }) -- template object must be an version 1.1.0");
  const templateData = template.data;
  const messages = await Promise.all(templateData.messages.map(async templateMessage => [genHash(templateMessage.key), await Promise.all(templateMessage.i18n.map(async templateMessagei18n => [genHash(templateMessagei18n.tag), genHash(templateMessagei18n.translation)]))]));
  const params = await Promise.all(templateData?.["parameters"].sort((a, b) => a.index - b.index).map(async arg => [genHash(arg.label), [genHash(String(arg.index)), genHash(arg.type), await Promise.all(arg.messages.map(async argumentMessage => [genHash(argumentMessage.key), await Promise.all(argumentMessage.i18n.map(async argumentMessagei18n => [genHash(argumentMessagei18n.tag), genHash(argumentMessagei18n.translation)]))]))]]));
  const dependencies = [await generateContractDependencies(templateData?.dependencies)];
  const encodedHex = rlp.encode([genHash(template?.f_type), genHash(template?.f_version), genHash(templateData?.type), genHash(templateData?.interface), messages, genHash(templateData?.cadence?.body), [dependencies], params]).toString("hex");
  return genHash(encodedHex);
}

/**
 * @description Generates Interaction Template ID for a given Interaction Template
 *
 * @param {object} params
 * @param {object} params.template - Interaction Template
 * @returns {Promise<string>} - Interaction Template ID
 */
async function generateTemplateId(_ref) {
  let {
    template
  } = _ref;
  utilInvariant.invariant(template, "generateTemplateId({ template }) -- template must be defined");
  utilInvariant.invariant(typeof template === "object", "generateTemplateId({ template }) -- template must be an object");
  utilInvariant.invariant(template.f_type === "InteractionTemplate", "generateTemplateId({ template }) -- template object must be an InteractionTemplate");
  switch (template.f_version) {
    case "1.1.0":
      return await generateTemplateId$1({
        template
      });
    case "1.0.0":
      return await generateTemplateId$2({
        template
      });
    default:
      throw new Error("generateTemplateId Error: Unsupported template version");
  }
}

/**
 * @description Verifies the given Interaction Template Id has been correctly generated
 *
 * @param {object} params
 * @param {object} params.template - Interaction Template
 * @returns {Promise<boolean>} - true or false, Interaction Template ID
 */

async function verifyGeneratedTemplateId(_ref2) {
  let {
    template
  } = _ref2;
  return template.id === (await generateTemplateId({
    template
  }));
}

/**
 * @description Returns whether a set of auditors have audited a given Interaction Template
 *
 * @param {object} params
 * @param {object} params.template - Interaction Template
 * @param {Array<string>} params.auditors - Array of auditors
 * @param {object} opts
 * @param {string} opts.flowInteractionAuditContract - Flow Interaction Template Audit contract address
 * @returns {Promise<object>} - Object of auditor addresses and audit status
 */
async function getInteractionTemplateAudits(_ref) {
  let {
    template,
    auditors
  } = _ref;
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  sdk.invariant(template != undefined, "getInteractionTemplateAudits({ template }) -- template must be defined");
  sdk.invariant(template.f_type === "InteractionTemplate", "getInteractionTemplateAudits({ template }) -- template must be an InteractionTemplate");

  // Recompute ID to be sure it matches
  let recomputedTemplateID = await generateTemplateId({
    template
  });
  if (recomputedTemplateID !== template.id) {
    logger.log({
      title: "getInteractionTemplateAudits Debug Error",
      message: `Could not recompute and match template ID
                computed: ${recomputedTemplateID}
                template: ${template.id}
            `,
      level: logger.LEVELS.debug
    });
    throw new Error("getInteractionTemplateAudits Error: Could not recompute and match template ID");
  }
  switch (template.f_version) {
    case "1.1.0":
    case "1.0.0":
      const _auditors = auditors || (await sdk.config().get("flow.auditors"));
      sdk.invariant(_auditors, "getInteractionTemplateAudits Error: Required configuration for 'fcl.auditors' is not set");
      sdk.invariant(Array.isArray(_auditors), "getInteractionTemplateAudits Error: Required configuration for 'fcl.auditors' is not an array");
      let FlowInteractionAuditContract = opts.flowInteractionAuditContract;
      if (!FlowInteractionAuditContract) {
        const fclNetwork = await getChainId(opts);
        sdk.invariant(fclNetwork === "mainnet" || fclNetwork === "testnet", "getInteractionTemplateAudits Error: Unable to determine address for FlowInteractionTemplateAudit contract. Set configuration for 'fcl.network' to 'mainnet' or 'testnet'");
        if (fclNetwork === "mainnet") {
          FlowInteractionAuditContract = "0xfd100e39d50a13e6";
        } else {
          FlowInteractionAuditContract = "0xf78bfc12d0a786dc";
        }
      }
      const audits = await query({
        cadence: `
        import FlowInteractionTemplateAudit from ${FlowInteractionAuditContract}
        access(all) fun main(templateId: String, auditors: [Address]): {Address:Bool} {
          return FlowInteractionTemplateAudit.getHasTemplateBeenAuditedByAuditors(templateId: templateId, auditors: auditors)
        }
        `,
        args: (arg, t) => [arg(recomputedTemplateID, t.String), arg(_auditors, t.Array(t.Address))]
      });
      return audits;
    default:
      throw new Error("getInteractionTemplateAudits Error: Unsupported template version");
  }
}

/**
 * @description Produces a dependency pin for a contract at current state of chain
 * @param {object} params
 * @param {string} params.address - The address of the account containing the contract
 * @param {string} params.contractName - The name of the contract
 * @param {object} opts - Options to pass to the interaction
 * @returns {Promise<string>} - The dependency pin
 */
async function generateDependencyPin100(_ref) {
  let {
    address,
    contractName
  } = _ref;
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  sdk.invariant(address != undefined, "generateDependencyPin({ address }) -- address must be defined");
  sdk.invariant(contractName != undefined, "generateDependencyPin({ contractName }) -- contractName must be defined");
  sdk.invariant(typeof address === "string", "generateDependencyPin({ address }) -- address must be a string");
  sdk.invariant(typeof contractName === "string", "generateDependencyPin({ contractName }) -- contractName must be a string");
  const horizon = [generateImport({
    contractName,
    address
  })];
  for (const horizonImport of horizon) {
    const account = await sdk.send([sdk.getAccount(await sdk.config().get(horizonImport.address, horizonImport.address))], opts).then(sdk.decode);
    horizonImport.contract = account.contracts?.[horizonImport.contractName];
    if (!horizonImport.contract) {
      console.error("Did not find expected contract", horizonImport, account);
      throw new Error("Did not find expected contract");
    }
    const contractImports = findImports(horizonImport.contract);
    horizon.push(...contractImports);
  }
  const contractHashes = horizon.map(iport => genHash(iport.contract));
  const contractHashesJoined = contractHashes.join("");
  return genHash(contractHashesJoined);
}

/**
 * @description Produces a dependency pin for a contract at current state of chain
 * @param {object} params
 * @param {string} params.version - The version of the interaction template
 * @param {string} params.address - The address of the account containing the contract
 * @param {string} params.contractName - The name of the contract
 * @param {object} opts - Options to pass to the interaction
 * @returns {Promise<string>} - The dependency pin
 */
async function generateDependencyPin(_ref) {
  let {
    version,
    address,
    contractName
  } = _ref;
  sdk.invariant(address != undefined, "generateDependencyPin({ address }) -- address must be defined");
  sdk.invariant(contractName != undefined, "generateDependencyPin({ contractName }) -- contractName must be defined");
  sdk.invariant(typeof address === "string", "generateDependencyPin({ address }) -- address must be a string");
  sdk.invariant(typeof contractName === "string", "generateDependencyPin({ contractName }) -- contractName must be a string");
  switch (version) {
    case "1.1.0":
      return await generateDependencyPin110({
        address,
        contractName
      });
    case "1.0.0":
      return await generateDependencyPin100({
        address,
        contractName
      });
    default:
      throw new Error("deriveCadenceByNetwork Error: Unsupported template version");
  }
}

/**
 * @description Produces a dependency pin for a contract at latest sealed block
 * @param {object} params
 * @param {string} params.version - The version of the interaction template
 * @param {string} params.address - The address of the account containing the contract
 * @param {string} params.contractName - The name of the contract
 * @param {object} opts - Options to pass to the interaction
 * @returns {Promise<string>} - The dependency pin
 */
async function generateDependencyPinAtLatestSealedBlock(_ref2) {
  let {
    version,
    address,
    contractName
  } = _ref2;
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const latestSealedBlock = await sdk.block({
    sealed: true
  }, opts);
  const latestSealedBlockHeight = latestSealedBlock?.height;
  return generateDependencyPin({
    version,
    address,
    contractName,
    blockHeight: latestSealedBlockHeight
  });
}

/**
 * @description Checks if an Interaction Template's pins match those generated at a block height
 *
 * @param {object} params
 * @param {object} params.template - Interaction Template to check pins for
 * @param {number} params.blockHeight - Block height to check pins at
 * @param {string} params.network - Network to check pins on
 * @param {object} opts
 * @returns {Promise<boolean>} - Whether or not the pins match
 */
async function verifyDependencyPinsSame(_ref) {
  let {
    template,
    blockHeight,
    network
  } = _ref;
  sdk.invariant(template != undefined, "generateDependencyPin({ template }) -- template must be defined");
  sdk.invariant(typeof template === "object", "generateDependencyPin({ template }) -- template must be an object");
  sdk.invariant(template.f_type === "InteractionTemplate", "generateDependencyPin({ template }) -- template must be an InteractionTemplate");
  sdk.invariant(network != undefined, "generateDependencyPin({ network }) network must be defined");
  sdk.invariant(blockHeight != undefined, "generateDependencyPin({ blockHeight }) blockHeight must be defined");
  sdk.invariant(typeof blockHeight === "number", "generateDependencyPin({ blockHeight }) blockHeight must be a number");
  switch (template.f_version) {
    case "1.0.0":
      const templateDependenciesPlaceholderKeys = Object.keys(template.data.dependencies);
      for (let templateDependencyPlaceholderKey of templateDependenciesPlaceholderKeys) {
        const templateDependencyPlaceholder = template.data.dependencies[templateDependencyPlaceholderKey];
        const templateDependencyPlaceholderContractNames = Object.keys(templateDependencyPlaceholder);
        for (let templateDependencyPlaceholderContractName of templateDependencyPlaceholderContractNames) {
          const templateDependencyPlaceholderContractNetworks = template.data.dependencies[templateDependencyPlaceholderKey][templateDependencyPlaceholderContractName];
          const templateDependency = templateDependencyPlaceholderContractNetworks[network];
          if (typeof templateDependency === "undefined") continue;
          const pin = await generateDependencyPin({
            address: templateDependency.address,
            contractName: templateDependency.contract,
            blockHeight
          });
          if (pin !== templateDependency.pin) {
            logger.log({
              title: "verifyDependencyPinsSame Debug Error",
              message: `Could not recompute and match dependency pin.
                                address: ${templateDependency.address} | contract: ${templateDependency.contract}
                                computed: ${pin}
                                template: ${templateDependency.pin}
                            `,
              level: logger.LEVELS.debug
            });
            return false;
          }
        }
      }
      return true;
    case "1.1.0":
      let isVerified = false;
      // iterate over each dependency
      for (let i = 0; i < template.data?.dependencies.length; i++) {
        const dependency = template.data?.dependencies[i];
        // iterate over each contract in dependency
        for (let j = 0; j < dependency?.contracts.length; j++) {
          const contract = dependency?.contracts[j];
          // iterate over each network in contract
          for (let k = 0; k < contract?.networks.length; k++) {
            const net = contract?.networks[k];
            // if network matches, generate pin and compare
            if (net.network === network) {
              const pin = await generateDependencyPin({
                version: template.f_version,
                address: net.address,
                contractName: contract.contract,
                blockHeight
              });
              if (pin !== net.dependency_pin.pin) {
                logger.log({
                  title: "verifyDependencyPinsSame Debug Error",
                  message: `Could not recompute and match dependency pin.
                                    address: ${net.address} | contract: ${contract.contract}
                                    computed: ${pin}
                                    template: ${net.pin}
                                `,
                  level: logger.LEVELS.debug
                });
                return false;
              } else {
                isVerified = true;
              }
            }
          }
        }
      }
      return isVerified;
    default:
      throw new Error("verifyDependencyPinsSame Error: Unsupported template version");
  }
}

/**
 * @description Checks if an Interaction Template's pins match those generated at the latest block height
 *
 * @param {object} params
 * @param {object} params.template - Interaction Template to check pins for
 * @param {string} params.network - Network to check pins on
 * @param {object} opts
 * @returns {Promise<boolean>} - Whether or not the pins match
 */
async function verifyDependencyPinsSameAtLatestSealedBlock(_ref2) {
  let {
    template,
    network
  } = _ref2;
  const latestSealedBlock = await sdk.block({
    sealed: true
  });
  const latestSealedBlockHeight = latestSealedBlock?.height;
  return verifyDependencyPinsSame({
    template,
    network,
    blockHeight: latestSealedBlockHeight
  });
}

/**
 * @description Get Interaction Template argument message
 *
 * @param {object} params
 * @param {string} params.localization [localization="en-US"] - Localization code
 * @param {string} params.messageKey - Message key
 * @param {object} params.template - Interaction Template
 * @returns {string} - Message
 */
function getTemplateMessage(_ref) {
  let {
    localization = "en-US",
    messageKey,
    template
  } = _ref;
  sdk.invariant(messageKey, "getTemplateMessage({ messageKey }) -- messageKey must be defined");
  sdk.invariant(typeof messageKey === "string", "getTemplateMessage({ messageKey }) -- messageKey must be a string");
  sdk.invariant(localization, "getTemplateMessage({ localization }) -- localization must be defined");
  sdk.invariant(typeof localization === "string", "getTemplateMessage({ localization }) -- localization must be a string");
  sdk.invariant(template != undefined, "getTemplateMessage({ template }) -- template must be defined");
  sdk.invariant(typeof template === "object", "getTemplateMessage({ template }) -- template must be an object");
  sdk.invariant(typeof template.f_type === "InteractionTemplate", "getTemplateMessage({ template }) -- template object must be an InteractionTemplate");
  switch (template.f_version) {
    case "1.1.0":
      const msg = template?.data?.messages?.find(a => a.key === messageKey);
      if (!msg) return undefined;
      const lzn = msg?.i18n?.find(a => a.tag === localization);
      if (!lzn) return undefined;
      return lzn.translation;
    case "1.0.0":
      return template?.data?.messages?.[messageKey]?.i18n?.[localization];
    default:
      throw new Error("getTemplateArgumentMessage Error: Unsupported template version");
  }
}

/**
 * @description Gets Interaction Template argument message by message key, argument label, and localization
 *
 * @param {object} opts
 * @param {string} opts.localization [localization="en-US"] - Localization to get message for
 * @param {string} opts.argumentLabel - Argument label to get message for
 * @param {string} opts.messageKey - Message key to get message for
 * @param {object} opts.template - Interaction Template to get message from
 * @returns {string} - Message
 */
function getTemplateArgumentMessage(_ref) {
  let {
    localization = "en-US",
    argumentLabel,
    messageKey,
    template
  } = _ref;
  sdk.invariant(messageKey, "getTemplateArgumentMessage({ messageKey }) -- messageKey must be defined");
  sdk.invariant(typeof messageKey === "string", "getTemplateArgumentMessage({ messageKey }) -- messageKey must be a string");
  sdk.invariant(argumentLabel, "getTemplateArgumentMessage({ argumentLabel }) -- argumentLabel must be defined");
  sdk.invariant(typeof messageKey === "string", "getTemplateArgumentMessage({ argumentLabel }) -- argumentLabel must be a string");
  sdk.invariant(localization, "getTemplateArgumentMessage({ localization }) -- localization must be defined");
  sdk.invariant(typeof localization === "string", "getTemplateArgumentMessage({ localization }) -- localization must be a string");
  sdk.invariant(template != undefined, "getTemplateArgumentMessage({ template }) -- template must be defined");
  sdk.invariant(typeof template === "object", "getTemplateArgumentMessage({ template }) -- template must be an object");
  sdk.invariant(typeof template.f_type === "InteractionTemplate", "getTemplateArgumentMessage({ template }) -- template object must be an InteractionTemplate");
  switch (template.f_version) {
    case "1.1.0":
      const param = template?.data?.parameters?.find(a => a.label === argumentLabel);
      if (!param) return undefined;
      const message = param?.messages?.find(a => a.key === messageKey);
      if (!message) return undefined;
      const lzn = message?.i18n?.find(a => a.tag === localization);
      if (!lzn) return undefined;
      return lzn.translation;
    case "1.0.0":
      return template?.data?.arguments?.[argumentLabel]?.messages?.[messageKey]?.i18n?.[localization];
    default:
      throw new Error("getTemplateArgumentMessage Error: Unsupported template version");
  }
}

var index = /*#__PURE__*/Object.freeze({
  __proto__: null,
  getInteractionTemplateAudits: getInteractionTemplateAudits,
  generateDependencyPin: generateDependencyPin,
  generateDependencyPinAtLatestSealedBlock: generateDependencyPinAtLatestSealedBlock,
  generateTemplateId: generateTemplateId,
  verifyGeneratedTemplateId: verifyGeneratedTemplateId,
  verifyDependencyPinsSame: verifyDependencyPinsSame,
  verifyDependencyPinsSameAtLatestSealedBlock: verifyDependencyPinsSameAtLatestSealedBlock,
  deriveCadenceByNetwork: deriveCadenceByNetwork,
  getTemplateMessage: getTemplateMessage,
  getTemplateArgumentMessage: getTemplateArgumentMessage
});

async function fetchServices(servicesURL, code) {
  if (servicesURL == null || code == null) return [];
  const url = new URL(servicesURL);
  url.searchParams.append("code", code);
  const resp = await fetch(url, {
    method: "GET",
    headers: {
      "Content-Type": "application/json"
    }
  }).then(d => d.json());
  if (Array.isArray(resp)) return resp;

  // Backwards compatibility for First-Gen Wallet Providers
  const services = [];

  // Convert authorizations into authz services
  if (Array.isArray(resp.authorizations)) {
    for (let service of resp.authorizations) {
      services.push({
        type: "authz",
        keyId: resp.keyId,
        ...service
      });
    }
  }

  // Convert Provider info into an authn service
  if (resp.provider != null) {
    services.push({
      type: "authn",
      id: "wallet-provider#authn",
      ...resp.provider
    });
  }
  return services;
}

function mergeServices() {
  let sx1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  let sx2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  // TODO: Make this smarter
  return [...sx1, ...sx2];
}

// {
//   "f_type": "Service",
//   "f_vsn": "1.0.0",
//   "type": "authn",
//   "uid": "uniqueDedupeKey",
//   "endpoint": "https://rawr",
//   "id": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx", // wallets internal id for the user
//   "identity": {
//     "address": "0x____"
//   },
//   "provider": {
//     "address": "0x____",
//     "name": "Best Wallet",
//     "description": "The Best Wallet"
//     "icon": "https://",
//   }
// }
function normalizeAuthn(service) {
  if (service == null) return null;
  if (!service["f_vsn"]) {
    return {
      ...SERVICE_PRAGMA,
      type: service.type,
      uid: service.id,
      endpoint: service.authn,
      id: service.pid,
      provider: {
        address: utilAddress.withPrefix(service.addr),
        name: service.name,
        icon: service.icon
      }
    };
  }
  switch (service["f_vsn"]) {
    case "1.0.0":
      return service;
    default:
      return null;
  }
}

// {
//   "f_type": "service",
//   "f_vsn": "1.0.0",
//   "type": "authz",
//   "uid": "uniqueDedupeKey",
//   "endpoint": "https://rawr",
//   "method": "HTTP/POST", // HTTP/POST | IFRAME/RPC | HTTP/RPC
//   "identity": {
//      "address": "0x______",
//      "keyId": 0,
//   },
//   "data": {}, // included in body of authz request
//   "params": {}, // included as query params on endpoint url
// }
function normalizeAuthz(service) {
  if (service == null) return null;
  if (!service["f_vsn"]) {
    return {
      ...SERVICE_PRAGMA,
      type: service.type,
      uid: service.id,
      endpoint: service.endpoint,
      method: service.method,
      identity: {
        ...IDENTITY_PRAGMA,
        address: utilAddress.withPrefix(service.addr),
        keyId: service.keyId
      },
      params: service.params,
      data: service.data
    };
  }
  switch (service["f_vsn"]) {
    case "1.0.0":
      return service;
    default:
      return null;
  }
}

// {
//   "f_type": "service",
//   "f_vsn": "1.0.0",
//   "type": "pre-authz",
//   "uid": "uniqueDedupeKey",
//   "endpoint": "https://rawr",
//   "method": "HTTP/POST", // HTTP/POST | IFRAME/RPC | HTTP/RPC
//   "identity": {
//      "address": "0x______",
//      "keyId": 0,
//   },
//   "data": {}, // included in body of pre-authz request
//   "params": {}, // included as query params on endpoint url
// }
function normalizePreAuthz(service) {
  if (service == null) return null;
  if (!service["f_vsn"]) {
    return {
      ...SERVICE_PRAGMA,
      type: service.type,
      uid: service.id,
      endpoint: service.endpoint,
      method: service.method,
      identity: {
        ...IDENTITY_PRAGMA,
        address: utilAddress.withPrefix(service.addr),
        keyId: service.keyId
      },
      params: service.params,
      data: service.data
    };
  }
  switch (service["f_vsn"]) {
    case "1.0.0":
      return service;
    default:
      return null;
  }
}

// {
//    "f_type": "Service",
//    "f_vsn": "1.0.0",
//    "type": "frame",
//    "endpoint": "https://rawr",
//    "data": {},   // Sent to frame when ready
//    "params": {}, // include in query params on frame
// }
function normalizeFrame(service) {
  if (service == null) return null;
  if (!service["f_vsn"]) {
    return {
      old: service,
      ...SERVICE_PRAGMA,
      type: "frame",
      endpoint: service.endpoint,
      params: service.params || {},
      data: service.data || {}
    };
  }
  switch (service["f_vsn"]) {
    case "1.0.0":
      return service;
    default:
      return null;
  }
}

// {
//    "f_type": "Service",
//    "f_vsn": "1.0.0",
//    "type": "back-channel-rpc",
//    "endpoint": "https://rawr",
//    "method": "HTTP/GET", // HTTP/GET | HTTP/POST
//    "data": {},           // included in body of rpc
//    "params": {},         // included as query params on endpoint url
// }
function normalizeBackChannelRpc(service) {
  if (service == null) return null;
  if (!service["f_vsn"]) {
    return {
      ...SERVICE_PRAGMA,
      type: "back-channel-rpc",
      endpoint: service.endpoint,
      method: service.method,
      params: service.params || {},
      data: service.data || {}
    };
  }
  switch (service["f_vsn"]) {
    case "1.0.0":
      return service;
    default:
      return null;
  }
}

// {
//   "f_type": "Service",
//   "f_vsn": "1.0.0",
//   "type": "open-id",
//   "uid": "uniqueDedupeKey",
//   "method: "data",
//   "data": {
//      "profile": {
//        "name": "Bob",
//        "family_name": "Builder",
//        "given_name": "Robert",
//        "middle_name": "the",
//        "nickname": "Bob the Builder",
//        "perferred_username": "bob",
//        "profile": "https://www.bobthebuilder.com/",
//        "picture": "https://avatars.onflow.org/avatar/bob",
//        "gender": "...",
//        "birthday": "2001-01-18",
//        "zoneinfo": "America/Vancouver",
//        "locale": "en-us",
//        "updated_at": "1614970797388"
//      },
//      "email": {
//        "email": "bob@bob.bob",
//        "email_verified": true
//      },
//      "address": {
//        "address": "One Apple Park Way, Cupertino, CA 95014, USA"
//      },
//      "phone": {
//        "phone_number": "+1 (xxx) yyy-zzzz",
//        "phone_number_verified": true
//      },
//      "social": {
//        "twitter": "@_qvvg",
//        "twitter_verified": true
//      },
//   }
// }
function normalizeOpenId(service) {
  if (service == null) return null;
  switch (service["f_vsn"]) {
    case "1.0.0":
      return service;
    default:
      return null;
  }
}

// {
//   "f_type": "Service",
//   "f_vsn": "1.0.0",
//   "type": "user-signature",
//   "uid": "uniqueDedupeKey",
//   "endpoint": "https://rawr",
//   "method": "IFRAME/RPC", // HTTP/POST | IFRAME/RPC | HTTP/RPC
//   "id": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx", // wallets internal id for the user
//   "data": {}, // included in body of user-signature request
//   "params": {}, // included as query params on endpoint url
// }
function normalizeUserSignature(service) {
  if (service == null) return null;
  if (!service["f_vsn"]) {
    throw new Error("Invalid user-signature service");
  }
  switch (service["f_vsn"]) {
    case "1.0.0":
      return service;
    default:
      return null;
  }
}

// {
//    "f_type": "Service",
//    "f_vsn": "1.0.0",
//    type: "local-view",
//    method: "VIEW/IFRAME",
//    endpoint: "https://woot.org/authz/local",
//    data: {},
//    params: {},
// }
function normalizeLocalView(resp) {
  if (resp == null) return null;
  if (resp.method == null) {
    resp = {
      ...resp,
      type: "local-view",
      method: "VIEW/IFRAME"
    };
  }
  if (!resp["f_vsn"]) {
    return {
      ...SERVICE_PRAGMA,
      type: resp.type || "local-view",
      method: resp.method,
      endpoint: resp.endpoint,
      data: resp.data || {},
      params: resp.params || {}
    };
  }
  switch (resp["f_vsn"]) {
    case "1.0.0":
      return resp;
    default:
      return null;
  }
}

// {
//   "f_type": "Service",                    // Its a service!
//   "f_vsn": "1.0.0",                       // Follows the v1.0.0 spec for the service
//   "type": "account-proof",                // the type of service it is
//   "method": "DATA",                       // Its data!
//   "uid": "awesome-wallet#account-proof",  // A unique identifier for the service
//   "data": {
//     "f_type": "account-proof",
//     "f_vsn": "1.0.0",
//     "nonce": "0A1BC2FF",                  // Nonce signed by the current account-proof (minimum 32 bytes in total, i.e 64 hex characters)
//     "address": "0xUSER",                  // The user's address (8 bytes, i.e 16 hex characters)
//     "signature": CompositeSignature,      // address (sans-prefix), keyId, signature (hex)
// }

function normalizeAccountProof(service) {
  if (service == null) return null;
  if (!service["f_vsn"]) {
    throw new Error(`FCL Normalizer Error: Invalid account-proof service`);
  }
  switch (service["f_vsn"]) {
    case "1.0.0":
      return service;
    default:
      return null;
  }
}

// {
//   "f_type": "Service",
//   "f_vsn": "1.0.0",
//   "type": "authn-refresh",
//   "uid": "uniqueDedupeKey",
//   "endpoint": "https://rawr",
//   "method": "HTTP/POST",  // "HTTP/POST", // HTTP/POST | IFRAME/RPC | HTTP/RPC
//   "id": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx", // wallets internal id for the user
//   "data": {}, // included in body of request
//   "params": {}, // included as query params on endpoint url
// }
function normalizeAuthnRefresh(service) {
  if (service == null) return null;
  if (!service["f_vsn"]) {
    throw new Error("Invalid authn-refresh service");
  }
  switch (service["f_vsn"]) {
    case "1.0.0":
      return service;
    default:
      return null;
  }
}

function normalizeServices(services, data) {
  return services.map(service => normalizeService(service, data)).filter(Boolean);
}
const serviceNormalizers = {
  "back-channel-rpc": normalizeBackChannelRpc,
  "pre-authz": normalizePreAuthz,
  authz: normalizeAuthz,
  authn: normalizeAuthn,
  frame: normalizeFrame,
  "open-id": normalizeOpenId,
  "user-signature": normalizeUserSignature,
  "local-view": normalizeLocalView,
  "account-proof": normalizeAccountProof,
  "authn-refresh": normalizeAuthnRefresh
};
function normalizeService(service, data) {
  try {
    var normalized = serviceNormalizers[service.type](service, data);
    return normalized;
  } catch (error) {
    console.error(`Unrecognized FCL Service Type [${service.type}]`, service, error);
    return service;
  }
}

function serviceOfType() {
  let services = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  let type = arguments.length > 1 ? arguments[1] : undefined;
  // Find the greatest version of the service type
  return services.reduce((mostRecent, service) => service.type === type ? !mostRecent || semver__namespace.compare(service.f_vsn, mostRecent.f_vsn) > 0 ? service : mostRecent : mostRecent, null);
}

function deriveCompositeId(authn) {
  return rlp__namespace.encode([authn.provider.address || authn.provider.name || "UNSPECIFIED", authn.id]).toString("hex");
}
function normalizeData(data) {
  data.addr = data.addr ? utilAddress.withPrefix(data.addr) : null;
  data.paddr = data.paddr ? utilAddress.withPrefix(data.paddr) : null;
  return data;
}
async function buildUser(data) {
  data = normalizeData(data);
  var services = normalizeServices(mergeServices(data.services || [], await fetchServices(data.hks, data.code)));
  const authn = serviceOfType(services, "authn");
  return {
    ...USER_PRAGMA,
    addr: utilAddress.withPrefix(data.addr),
    cid: deriveCompositeId(authn),
    loggedIn: true,
    services: services,
    expiresAt: data.expires
  };
}

const FCL_WC_SERVICE_METHOD = "WC/RPC";
const isServerSide = typeof window === "undefined";

// Utility to notify the user if the Walletconnect service plugin has not been loaded
function checkWalletConnectEnabled() {
  if (isServerSide) return;
  const serviceRegistry = getServiceRegistry();
  const strategies = serviceRegistry.getStrategies();
  if (!strategies.includes(FCL_WC_SERVICE_METHOD)) {
    logger__namespace.log({
      title: "FCL WalletConnect Service Plugin",
      level: logger__namespace.LEVELS.error,
      message: "All dApps are expected to register for a WalletConnect projectId & add this to their FCL configuration.  If you do not do so, users will be unable to use certain wallets to interact with your dApp.  See https://developers.flow.com/tools/clients/fcl-js/configure-fcl for more information."
    });
  }
}

const execStrategy = async _ref => {
  let {
    service,
    body,
    config,
    opts
  } = _ref;
  const strategy = getServiceRegistry().getStrategy(service.method);
  return strategy({
    service,
    body,
    config,
    opts
  });
};
async function execService(_ref2) {
  let {
    service,
    msg = {},
    config = {},
    opts = {},
    platform
  } = _ref2;
  // Notify the developer if WalletConnect is not enabled
  checkWalletConnectEnabled();
  msg.data = service.data;
  const execConfig = {
    services: await configLens(/^service\./),
    app: await configLens(/^app\.detail\./),
    client: {
      ...config.client,
      platform,
      fclVersion: VERSION,
      fclLibrary: "https://github.com/onflow/fcl-js",
      hostname: window?.location?.hostname ?? null,
      network: await getChainId(opts)
    }
  };
  try {
    const res = await execStrategy({
      service,
      body: msg,
      config: execConfig,
      opts
    });
    if (res.status === "REDIRECT") {
      utilInvariant.invariant(service.type === res.data.type, "Cannot shift recursive service type in execService");
      return await execService({
        service: res.data,
        msg,
        config: execConfig,
        opts
      });
    } else {
      return res;
    }
  } catch (error) {
    logger.log({
      title: `Error on execService ${service?.type}`,
      message: error,
      level: logger.LEVELS.error
    });
    throw error;
  }
}

// {
//    "f_type": "CompositeSignature",
//    "f_vsn": "1.0.0",
//    "addr": "_____",         // sans-prefix
//    "signature": "adfe1234", // hex
//    "keyId": 3,
// }
function normalizeCompositeSignature(resp) {
  if (resp == null) return null;
  if (!resp["f_vsn"]) {
    return {
      ...COMPOSITE_SIGNATURE_PRAGMA,
      addr: utilAddress.sansPrefix(resp.addr || resp.address),
      signature: resp.signature || resp.sig,
      keyId: resp.keyId
    };
  }
  switch (resp["f_vsn"]) {
    case "1.0.0":
      return resp;
    default:
      return null;
  }
}

/**
 * @typedef {import("@onflow/typedefs").CurrentUser} CurrentUser
 * @typedef {import("@onflow/typedefs").CompositeSignature} CompositeSignature
 */

const isFn = d => typeof d === "function";
const NAME = "CURRENT_USER";
const UPDATED = "CURRENT_USER/UPDATED";
const SNAPSHOT = "SNAPSHOT";
const SET_CURRENT_USER = "SET_CURRENT_USER";
const DEL_CURRENT_USER = "DEL_CURRENT_USER";
const DATA = `{
  "f_type": "User",
  "f_vsn": "1.0.0",
  "addr":null,
  "cid":null,
  "loggedIn":null,
  "expiresAt":null,
  "services":[]
}`;
const getStoredUser = async storage => {
  const fallback = JSON.parse(DATA);
  const stored = await storage.get(NAME);
  if (stored != null && fallback["f_vsn"] !== stored["f_vsn"]) {
    storage.removeItem(NAME);
    return fallback;
  }
  return stored || fallback;
};
const HANDLERS = {
  [utilActor.INIT]: async ctx => {
    if (typeof window === "undefined") {
      console.warn(`
        %cFCL Warning
        ============================
        "currentUser" is only available in the browser.
        For more info, please see the docs: https://docs.onflow.org/fcl/
        ============================
        `, "font-weight:bold;font-family:monospace;");
    }
    ctx.merge(JSON.parse(DATA));
    const storage = await config.config.first(["fcl.storage", "fcl.storage.default"]);
    if (storage.can) {
      const user = await getStoredUser(storage);
      if (notExpired(user)) ctx.merge(user);
    }
  },
  [utilActor.SUBSCRIBE]: (ctx, letter) => {
    ctx.subscribe(letter.from);
    ctx.send(letter.from, UPDATED, {
      ...ctx.all()
    });
  },
  [utilActor.UNSUBSCRIBE]: (ctx, letter) => {
    ctx.unsubscribe(letter.from);
  },
  [SNAPSHOT]: async (ctx, letter) => {
    letter.reply({
      ...ctx.all()
    });
  },
  [SET_CURRENT_USER]: async (ctx, letter, data) => {
    ctx.merge(data);
    const storage = await config.config.first(["fcl.storage", "fcl.storage.default"]);
    if (storage.can) storage.put(NAME, ctx.all());
    ctx.broadcast(UPDATED, {
      ...ctx.all()
    });
  },
  [DEL_CURRENT_USER]: async (ctx, letter) => {
    ctx.merge(JSON.parse(DATA));
    const storage = await config.config.first(["fcl.storage", "fcl.storage.default"]);
    if (storage.can) storage.put(NAME, ctx.all());
    ctx.broadcast(UPDATED, {
      ...ctx.all()
    });
  }
};
const spawnCurrentUser = () => utilActor.spawn(HANDLERS, NAME);
function notExpired(user) {
  return user.expiresAt == null || user.expiresAt === 0 || user.expiresAt > Date.now();
}
async function getAccountProofData() {
  let accountProofDataResolver = await config.config.get("fcl.accountProof.resolver");
  if (accountProofDataResolver == null) return;
  if (!isFn(accountProofDataResolver)) {
    logger.log({
      title: "Account Proof Data Resolver must be a function",
      message: `Check fcl.accountProof.resolver configuration.
                Expected: fcl.accountProof.resolver: async () => { ... }
                Received: fcl.accountProof.resolver: ${typeof accountProofDataResolver}
                `,
      level: logger.LEVELS.warn
    });
    return;
  }
  const accountProofData = await accountProofDataResolver();
  if (accountProofData == null) return;
  utilInvariant.invariant(typeof accountProofData.appIdentifier === "string", "appIdentifier must be a string");
  utilInvariant.invariant(/^[0-9a-f]+$/i.test(accountProofData.nonce), "Nonce must be a hex string");
  return accountProofData;
}
const makeConfig = async _ref => {
  let {
    discoveryAuthnInclude,
    discoveryFeaturesSuggested
  } = _ref;
  return {
    client: {
      discoveryAuthnInclude,
      discoveryFeaturesSuggested,
      clientServices: await makeDiscoveryServices(),
      supportedStrategies: getServiceRegistry().getStrategies()
    }
  };
};

/**
 * @description - Authenticate a user
 * @param {object} [opts] - Options
 * @param {object} [opts.platform] - platform that runs the function
 * @param {object} [opts.service] - Optional service to use for authentication
 * @param {boolean} [opts.redir=false] - Optional flag to allow window to stay open after authentication
 * @returns {function(*)Promise<CurrentUser>} - User object
 */
const getAuthenticate = _ref2 => {
  let {
    platform
  } = _ref2;
  return async function () {
    let {
      service,
      redir = false
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (service && !service?.provider?.is_installed && service?.provider?.requires_install) {
      window.location.href = service?.provider?.install_link;
      return;
    }
    return new Promise(async (resolve, reject) => {
      spawnCurrentUser();
      const opts = {
        redir
      };
      const user = await snapshot();
      const discoveryService = await getDiscoveryService(service);
      const refreshService = serviceOfType(user.services, "authn-refresh");
      let accountProofData;
      if (user.loggedIn) {
        if (refreshService) {
          try {
            const response = await execService({
              service: refreshService,
              msg: accountProofData,
              opts,
              platform
            });
            utilActor.send(NAME, SET_CURRENT_USER, await buildUser(response));
          } catch (error) {
            logger.log({
              title: `${error.name} Could not refresh wallet authentication.`,
              message: error.message,
              level: logger.LEVELS.error
            });
          } finally {
            return resolve(await snapshot());
          }
        } else {
          return resolve(user);
        }
      }
      try {
        accountProofData = await getAccountProofData();
      } catch (error) {
        logger.log({
          title: `${error.name} On Authentication: Could not resolve account proof data.`,
          message: error.message,
          level: logger.LEVELS.error
        });
        return reject(error);
      }
      try {
        const response = await execService({
          service: discoveryService,
          msg: accountProofData,
          config: await makeConfig(discoveryService),
          opts,
          platform
        });
        utilActor.send(NAME, SET_CURRENT_USER, await buildUser(response));
      } catch (error) {
        logger.log({
          title: `${error} On Authentication`,
          message: error,
          level: logger.LEVELS.error
        });
      } finally {
        resolve(await snapshot());
      }
    });
  };
};

/**
 * @description - Unauthenticate a user
 * @returns {void}
 */
function unauthenticate() {
  spawnCurrentUser();
  utilActor.send(NAME, DEL_CURRENT_USER);
}
const normalizePreAuthzResponse = authz => ({
  f_type: "PreAuthzResponse",
  f_vsn: "1.0.0",
  proposer: (authz || {}).proposer,
  payer: (authz || {}).payer || [],
  authorization: (authz || {}).authorization || []
});
const getResolvePreAuthz = _ref3 => {
  let {
    platform
  } = _ref3;
  return authz => {
    const resp = normalizePreAuthzResponse(authz);
    const axs = [];
    if (resp.proposer != null) axs.push(["PROPOSER", resp.proposer]);
    for (let az of resp.payer || []) axs.push(["PAYER", az]);
    for (let az of resp.authorization || []) axs.push(["AUTHORIZER", az]);
    var result = axs.map(_ref4 => {
      let [role, az] = _ref4;
      return {
        tempId: [az.identity.address, az.identity.keyId].join("|"),
        addr: az.identity.address,
        keyId: az.identity.keyId,
        signingFunction(signable) {
          return execService({
            service: az,
            msg: signable,
            platform
          });
        },
        role: {
          proposer: role === "PROPOSER",
          payer: role === "PAYER",
          authorizer: role === "AUTHORIZER"
        }
      };
    });
    return result;
  };
};

/**
 * @description
 * Produces the needed authorization details for the current user to submit transactions to Flow
 * It defines a signing function that connects to a user's wallet provider to produce signatures to submit transactions.
 *
 * @param {object} ops - running options
 * @param {string} ops.platform - platform that runs the function
 * @param {object} account - Account object
 * @returns {Promise<object>} - Account object with signing function
 */
const getAuthorization = _ref5 => {
  let {
    platform
  } = _ref5;
  return async account => {
    spawnCurrentUser();
    return {
      ...account,
      tempId: "CURRENT_USER",
      async resolve(account, preSignable) {
        const user = await getAuthenticate({
          platform
        })({
          redir: true
        });
        const authz = serviceOfType(user.services, "authz");
        const preAuthz = serviceOfType(user.services, "pre-authz");
        if (preAuthz) return getResolvePreAuthz({
          platform
        })(await execService({
          service: preAuthz,
          msg: preSignable,
          platform
        }));
        if (authz) {
          let windowRef;
          if (isMobile() && authz.method === "WC/RPC") {
            windowRef = window.open("", "_blank");
          }
          return {
            ...account,
            tempId: "CURRENT_USER",
            resolve: null,
            addr: utilAddress.sansPrefix(authz.identity.address),
            keyId: authz.identity.keyId,
            sequenceNum: null,
            signature: null,
            async signingFunction(signable) {
              return normalizeCompositeSignature(await execService({
                service: authz,
                msg: signable,
                opts: {
                  includeOlderJsonRpcCall: true,
                  windowRef
                },
                platform
              }));
            }
          };
        }
        throw new Error("No Authz or PreAuthz Service configured for CURRENT_USER");
      }
    };
  };
};

/**
 * @description
 * The callback passed to subscribe will be called when the user authenticates and un-authenticates, making it easy to update the UI accordingly.
 *
 * @param {Function} callback - Callback function
 * @returns {Function} - Unsubscribe function
 */
function subscribe(callback) {
  spawnCurrentUser();
  const EXIT = "@EXIT";
  const self = utilActor.spawn(async ctx => {
    ctx.send(NAME, utilActor.SUBSCRIBE);
    while (1) {
      const letter = await ctx.receive();
      if (letter.tag === EXIT) {
        ctx.send(NAME, utilActor.UNSUBSCRIBE);
        return;
      }
      callback(letter.data);
    }
  });
  return () => utilActor.send(self, EXIT);
}

/**
 * @description - Gets the current user
 * @returns {Promise<CurrentUser>} - User object
 */
function snapshot() {
  spawnCurrentUser();
  return utilActor.send(NAME, SNAPSHOT, null, {
    expectReply: true,
    timeout: 0
  });
}

/**
 * @description - Resolves the current user as an argument
 *
 * @param {object} ops - running options
 * @param {string} ops.platform - platform that runs the function
 * @returns {Promise<Function>}
 */
const getResolveArgument = _ref6 => {
  let {
    platform
  } = _ref6;
  return async () => {
    const {
      addr
    } = await getAuthenticate({
      platform
    })();
    return sdk.arg(utilAddress.withPrefix(addr), t__namespace.Address);
  };
};
const makeSignable = msg => {
  utilInvariant.invariant(/^[0-9a-f]+$/i.test(msg), "Message must be a hex string");
  return {
    message: msg
  };
};

/**
 * @description - A method to use allowing the user to personally sign data via FCL Compatible Wallets/Services.
 * @param {string} msg - Message to sign
 * @returns {Promise<CompositeSignature[]>} - Array of CompositeSignatures
 */
const getSignUserMessage = _ref7 => {
  let {
    platform
  } = _ref7;
  return async msg => {
    spawnCurrentUser();
    const user = await getAuthenticate({
      platform
    })({
      redir: true
    });
    const signingService = serviceOfType(user.services, "user-signature");
    utilInvariant.invariant(signingService, "Current user must have authorized a signing service.");
    try {
      const response = await execService({
        service: signingService,
        msg: makeSignable(msg),
        platform
      });
      if (Array.isArray(response)) {
        return response.map(compSigs => normalizeCompositeSignature(compSigs));
      } else {
        return [normalizeCompositeSignature(response)];
      }
    } catch (error) {
      return error;
    }
  };
};
const getCurrentUser = _ref8 => {
  let {
    platform
  } = _ref8;
  let currentUser = () => {
    return {
      authenticate: getAuthenticate({
        platform
      }),
      unauthenticate,
      authorization: getAuthorization({
        platform
      }),
      signUserMessage: getSignUserMessage({
        platform
      }),
      subscribe,
      snapshot,
      resolveArgument: getResolveArgument({
        platform
      })
    };
  };
  currentUser.authenticate = getAuthenticate({
    platform
  });
  currentUser.unauthenticate = unauthenticate;
  currentUser.authorization = getAuthorization({
    platform
  });
  currentUser.signUserMessage = getSignUserMessage({
    platform
  });
  currentUser.subscribe = subscribe;
  currentUser.snapshot = snapshot;
  currentUser.resolveArgument = getResolveArgument({
    platform
  });
  return currentUser;
};

const getMutate = _ref => {
  let {
    platform
  } = _ref;
  /**
   * @description
   * Allows you to submit transactions to the blockchain to potentially mutate the state.
   *
   * @param {object} [opts] - Mutation Options and configuration
   * @param {string} [opts.cadence] - Cadence Transaction used to mutate Flow
   * @param {import("../shared-exports").ArgsFn} [opts.args] - Arguments passed to cadence transaction
   * @param {object | string} [opts.template] - Interaction Template for a transaction
   * @param {number} [opts.limit] - Compute Limit for transaction
   * @param {Function} [opts.authz] - Authorization function for transaction
   * @param {Function} [opts.proposer] - Proposer Authorization function for transaction
   * @param {Function} [opts.payer] - Payer Authorization function for transaction
   * @param {Array<Function>} [opts.authorizations] - Authorizations function for transaction
   * @returns {Promise<string>} Transaction Id
   *
   * @example
   * fcl.mutate({
   *   cadence: `
   *     transaction(a: Int, b: Int, c: Address) {
   *       prepare(acct: AuthAccount) {
   *         log(acct)
   *         log(a)
   *         log(b)
   *         log(c)
   *       }
   *     }
   *   `,
   *   args: (arg, t) => [
   *     arg(6, t.Int),
   *     arg(7, t.Int),
   *     arg("0xba1132bc08f82fe2", t.Address),
   *   ],
   * })
   *
   *
   * Options:
   * type Options = {
   *   template: InteractionTemplate | String // InteractionTemplate or url to one
   *   cadence: String!,
   *   args: (arg, t) => Array<Arg>,
   *   limit: Number,
   *   authz: AuthzFn, // will overload the trinity of signatory roles
   *   proposer: AuthzFn, // will overload the proposer signatory role
   *   payer: AuthzFn, // will overload the payer signatory role
   *   authorizations: [AuthzFn], // an array of authorization functions used as authorizations signatory roles
   * }
   */
  const mutate = async function () {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var txid;
    try {
      await preMutate(opts);
      opts = await prepTemplateOpts(opts);
      const currentUser = getCurrentUser({
        platform
      });
      // Allow for a config to overwrite the authorization function.
      // prettier-ignore
      const authz = await sdk__namespace.config().get("fcl.authz", currentUser().authorization);
      txid = sdk__namespace.config().overload(opts.dependencies || {}, async () =>
      // prettier-ignore
      sdk__namespace.send([sdk__namespace.transaction(opts.cadence), sdk__namespace.args(normalizeArgs(opts.args || [])), opts.limit && isNumber(opts.limit) && sdk__namespace.limit(opts.limit),
      // opts.proposer > opts.authz > authz
      sdk__namespace.proposer(opts.proposer || opts.authz || authz),
      // opts.payer > opts.authz > authz
      sdk__namespace.payer(opts.payer || opts.authz || authz),
      // opts.authorizations > [opts.authz > authz]
      sdk__namespace.authorizations(opts.authorizations || [opts.authz || authz])]).then(sdk__namespace.decode));
      return txid;
    } catch (error) {
      throw error;
    }
  };
  return mutate;
};

function serviceEndpoint(service) {
  const url = new URL(service.endpoint);
  if (window?.location?.origin) {
    url.searchParams.append("l6n", window.location.origin);
  }
  if (service.params != null) {
    for (let [key, value] of Object.entries(service.params || {})) {
      url.searchParams.append(key, value);
    }
  }
  return url;
}

function fetchService(service) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const method = opts.method || "POST";
  const body = method === "GET" ? undefined : JSON.stringify(opts.data || service.data || {});
  return fetch(serviceEndpoint(service), {
    method: method,
    headers: {
      ...(service.headers || {}),
      ...(opts.headers || {}),
      "Content-Type": "application/json"
    },
    body: body
  }).then(d => d.json());
}

// {
//    "f_type": "PollingResponse",
//    "f_vsn": "1.0.0",
//    "status": "PENDING", // PENDING | APPROVED | DECLINED | REDIRECT
//    "reason": null,      // Reason for Declining Transaction
//    "data": null,        // Return value for APPROVED
//    "updates": BackChannelRpc,
//    "local": Frame,
// }
function normalizePollingResponse(resp) {
  if (resp == null) return null;
  if (!resp["f_vsn"]) {
    return {
      ...POLLING_RESPONSE_PRAGMA,
      status: resp.status ?? "APPROVED",
      reason: resp.reason ?? null,
      data: resp.compositeSignature || resp.data || {
        ...resp
      } || {},
      updates: normalizeBackChannelRpc(resp.authorizationUpdates),
      local: normalizeFrame((resp.local || [])[0])
    };
  }
  switch (resp["f_vsn"]) {
    case "1.0.0":
      return resp;
    default:
      return null;
  }
}

const OPTIONS = {
  "HTTP/GET": "GET",
  "HTTP/POST": "POST"
};
const serviceMethod = service => {
  utilInvariant.invariant(OPTIONS[service.method], "Invalid Service Method for type back-channel-rpc", {
    service
  });
  return OPTIONS[service.method];
};
async function poll(service) {
  let checkCanContinue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => true;
  utilInvariant.invariant(service, "Missing Polling Service", {
    service
  });
  const canContinue = checkCanContinue();
  if (!canContinue) throw new Error("Externally Halted");
  let resp;
  try {
    if (typeof document !== "undefined" && document.visibilityState === "hidden") {
      await new Promise(r => setTimeout(r, 500));
      return poll(service, checkCanContinue);
    }
    resp = await fetchService(service, {
      method: serviceMethod(service)
    }).then(normalizePollingResponse);
  } catch (error) {
    throw error;
  }
  switch (resp.status) {
    case "APPROVED":
      return resp.data;
    case "DECLINED":
      throw new Error(`Declined: ${resp.reason || "No reason supplied."}`);
    default:
      await new Promise(r => setTimeout(r, 500));
      return poll(resp.updates, checkCanContinue);
  }
}

const getExecHttpPost = execLocal => async _ref => {
  let {
    service,
    body,
    config,
    opts
  } = _ref;
  const resp = await fetchService(service, {
    data: {
      fclVersion: VERSION,
      service: {
        params: service.params,
        data: service.data,
        type: service.type
      },
      config,
      ...body
    }
  }).then(normalizePollingResponse);
  if (resp.status === "APPROVED") {
    return resp.data;
  } else if (resp.status === "DECLINED") {
    throw new Error(`Declined: ${resp.reason || "No reason supplied."}`);
  } else if (resp.status === "REDIRECT") {
    return resp;
  } else if (resp.status === "PENDING") {
    // these two flags are required to run polling one more time before it stops
    var canContinue = true;
    var shouldContinue = true;
    const [_, unmount] = await execLocal(normalizeLocalView(resp.local), {
      serviceEndpoint,
      onClose: () => shouldContinue = false
    });
    const close = () => {
      try {
        unmount();
        shouldContinue = false;
      } catch (error) {
        console.error("Frame Close Error", error);
      }
    };
    /**
     * this function is run once per poll call.
     * Offsetting canContinue flag to make sure that
     * the polling is performed one extra time after canContinue flag is set to false
     * to prevent halting on Android when a browser calls window.close
     * before FCL receives a successful result from polling
     *
     * @returns {boolean}
     */
    const checkCanContinue = () => {
      const offsetCanContinue = canContinue;
      canContinue = shouldContinue;
      return offsetCanContinue;
    };
    return poll(resp.updates, checkCanContinue).then(serviceResponse => {
      close();
      return serviceResponse;
    }).catch(error => {
      console.error(error);
      close();
      throw error;
    });
  } else {
    console.error(`Auto Decline: Invalid Response`, {
      service,
      resp
    });
    throw new Error(`Auto Decline: Invalid Response`);
  }
};

const CLOSE_EVENT = "FCL:VIEW:CLOSE";
const READY_EVENT = "FCL:VIEW:READY";
const RESPONSE_EVENT = "FCL:VIEW:RESPONSE";
const _ = e => typeof e === "string" && e.toLowerCase();
const IGNORE = new Set(["monetizationstart", "monetizationpending", "monetizationprogress", "monetizationstop"]);
const deprecate = (was, want) => console.warn("DEPRECATION NOTICE", `Received ${was}, please use ${want} for this and future versions of FCL`);
const buildMessageHandler = _ref => {
  let {
    close,
    send,
    onReady,
    onResponse,
    onMessage
  } = _ref;
  return e => {
    try {
      if (typeof e.data !== "object") return;
      if (IGNORE.has(e.data.type)) return;
      if (_(e.data.type) === _(CLOSE_EVENT)) close();
      if (_(e.data.type) === _(READY_EVENT)) onReady(e, {
        send,
        close
      });
      if (_(e.data.type) === _(RESPONSE_EVENT)) onResponse(e, {
        send,
        close
      });
      onMessage(e, {
        send,
        close
      });

      // Backwards Compatible
      if (_(e.data.type) === _("FCL:FRAME:READY")) {
        deprecate(e.data.type, READY_EVENT);
        onReady(e, {
          send,
          close
        });
      }
      if (_(e.data.type) === _("FCL:FRAME:RESPONSE")) {
        deprecate(e.data.type, RESPONSE_EVENT);
        onResponse(e, {
          send,
          close
        });
      }
      if (_(e.data.type) === _("FCL:FRAME:CLOSE")) {
        deprecate(e.data.type, CLOSE_EVENT);
        close();
      }
      //
      if (_(e.data.type) === _("FCL::CHALLENGE::RESPONSE")) {
        deprecate(e.data.type, RESPONSE_EVENT);
        onResponse(e, {
          send,
          close
        });
      }
      if (_(e.data.type) === _("FCL::AUTHZ_READY")) {
        deprecate(e.data.type, READY_EVENT);
        onReady(e, {
          send,
          close
        });
      }
      if (_(e.data.type) === _("FCL::CHALLENGE::CANCEL")) {
        deprecate(e.data.type, CLOSE_EVENT);
        close();
      }
      if (_(e.data.type) === _("FCL::CANCEL")) {
        deprecate(e.data.type, CLOSE_EVENT);
        close();
      }
    } catch (error) {
      console.error("Frame Callback Error", error);
      close();
    }
  };
};

// Set chain id default on access node change
watchForChainIdChanges();

Object.defineProperty(exports, 'TestUtils', {
  enumerable: true,
  get: function () { return sdk.TestUtils; }
});
Object.defineProperty(exports, 'account', {
  enumerable: true,
  get: function () { return sdk.account; }
});
Object.defineProperty(exports, 'arg', {
  enumerable: true,
  get: function () { return sdk.arg; }
});
Object.defineProperty(exports, 'args', {
  enumerable: true,
  get: function () { return sdk.args; }
});
Object.defineProperty(exports, 'atBlockHeight', {
  enumerable: true,
  get: function () { return sdk.atBlockHeight; }
});
Object.defineProperty(exports, 'atBlockId', {
  enumerable: true,
  get: function () { return sdk.atBlockId; }
});
Object.defineProperty(exports, 'authorization', {
  enumerable: true,
  get: function () { return sdk.authorization; }
});
Object.defineProperty(exports, 'authorizations', {
  enumerable: true,
  get: function () { return sdk.authorizations; }
});
Object.defineProperty(exports, 'block', {
  enumerable: true,
  get: function () { return sdk.block; }
});
Object.defineProperty(exports, 'build', {
  enumerable: true,
  get: function () { return sdk.build; }
});
Object.defineProperty(exports, 'createSignableVoucher', {
  enumerable: true,
  get: function () { return sdk.createSignableVoucher; }
});
Object.defineProperty(exports, 'decode', {
  enumerable: true,
  get: function () { return sdk.decode; }
});
Object.defineProperty(exports, 'getAccount', {
  enumerable: true,
  get: function () { return sdk.getAccount; }
});
Object.defineProperty(exports, 'getBlock', {
  enumerable: true,
  get: function () { return sdk.getBlock; }
});
Object.defineProperty(exports, 'getBlockHeader', {
  enumerable: true,
  get: function () { return sdk.getBlockHeader; }
});
Object.defineProperty(exports, 'getCollection', {
  enumerable: true,
  get: function () { return sdk.getCollection; }
});
Object.defineProperty(exports, 'getEvents', {
  enumerable: true,
  get: function () { return sdk.getEvents; }
});
Object.defineProperty(exports, 'getEventsAtBlockHeightRange', {
  enumerable: true,
  get: function () { return sdk.getEventsAtBlockHeightRange; }
});
Object.defineProperty(exports, 'getEventsAtBlockIds', {
  enumerable: true,
  get: function () { return sdk.getEventsAtBlockIds; }
});
Object.defineProperty(exports, 'getNetworkParameters', {
  enumerable: true,
  get: function () { return sdk.getNetworkParameters; }
});
Object.defineProperty(exports, 'getNodeVersionInfo', {
  enumerable: true,
  get: function () { return sdk.getNodeVersionInfo; }
});
Object.defineProperty(exports, 'getTransaction', {
  enumerable: true,
  get: function () { return sdk.getTransaction; }
});
Object.defineProperty(exports, 'getTransactionStatus', {
  enumerable: true,
  get: function () { return sdk.getTransactionStatus; }
});
Object.defineProperty(exports, 'invariant', {
  enumerable: true,
  get: function () { return sdk.invariant; }
});
Object.defineProperty(exports, 'isBad', {
  enumerable: true,
  get: function () { return sdk.isBad; }
});
Object.defineProperty(exports, 'isOk', {
  enumerable: true,
  get: function () { return sdk.isOk; }
});
Object.defineProperty(exports, 'limit', {
  enumerable: true,
  get: function () { return sdk.limit; }
});
Object.defineProperty(exports, 'nodeVersionInfo', {
  enumerable: true,
  get: function () { return sdk.nodeVersionInfo; }
});
Object.defineProperty(exports, 'param', {
  enumerable: true,
  get: function () { return sdk.param; }
});
Object.defineProperty(exports, 'params', {
  enumerable: true,
  get: function () { return sdk.params; }
});
Object.defineProperty(exports, 'payer', {
  enumerable: true,
  get: function () { return sdk.payer; }
});
Object.defineProperty(exports, 'ping', {
  enumerable: true,
  get: function () { return sdk.ping; }
});
Object.defineProperty(exports, 'pipe', {
  enumerable: true,
  get: function () { return sdk.pipe; }
});
Object.defineProperty(exports, 'proposer', {
  enumerable: true,
  get: function () { return sdk.proposer; }
});
Object.defineProperty(exports, 'ref', {
  enumerable: true,
  get: function () { return sdk.ref; }
});
Object.defineProperty(exports, 'script', {
  enumerable: true,
  get: function () { return sdk.script; }
});
Object.defineProperty(exports, 'send', {
  enumerable: true,
  get: function () { return sdk.send; }
});
Object.defineProperty(exports, 'subscribeEvents', {
  enumerable: true,
  get: function () { return sdk.subscribeEvents; }
});
Object.defineProperty(exports, 'transaction', {
  enumerable: true,
  get: function () { return sdk.transaction; }
});
Object.defineProperty(exports, 'validator', {
  enumerable: true,
  get: function () { return sdk.validator; }
});
Object.defineProperty(exports, 'voucherIntercept', {
  enumerable: true,
  get: function () { return sdk.voucherIntercept; }
});
Object.defineProperty(exports, 'voucherToTxId', {
  enumerable: true,
  get: function () { return sdk.voucherToTxId; }
});
Object.defineProperty(exports, 'why', {
  enumerable: true,
  get: function () { return sdk.why; }
});
exports.t = t__namespace;
Object.defineProperty(exports, 'config', {
  enumerable: true,
  get: function () { return config.config; }
});
Object.defineProperty(exports, 'display', {
  enumerable: true,
  get: function () { return utilAddress.display; }
});
Object.defineProperty(exports, 'sansPrefix', {
  enumerable: true,
  get: function () { return utilAddress.sansPrefix; }
});
Object.defineProperty(exports, 'withPrefix', {
  enumerable: true,
  get: function () { return utilAddress.withPrefix; }
});
Object.defineProperty(exports, 'cadence', {
  enumerable: true,
  get: function () { return utilTemplate.template; }
});
Object.defineProperty(exports, 'cdc', {
  enumerable: true,
  get: function () { return utilTemplate.template; }
});
exports.AppUtils = index$1;
exports.CORE_STRATEGIES = CORE_STRATEGIES;
exports.FCL_REDIRECT_URL_PARAM_NAME = FCL_REDIRECT_URL_PARAM_NAME;
exports.FCL_RESPONSE_PARAM_NAME = FCL_RESPONSE_PARAM_NAME;
exports.InteractionTemplateUtils = index;
exports.URL = URL;
exports.VERSION = VERSION;
exports.WalletUtils = index$2;
exports.buildMessageHandler = buildMessageHandler;
exports.discovery = discovery;
exports.events = events;
exports.getChainId = getChainId;
exports.getCurrentUser = getCurrentUser;
exports.getExecHttpPost = getExecHttpPost;
exports.getMutate = getMutate;
exports.initServiceRegistry = initServiceRegistry;
exports.isReactNative = isReactNative;
exports.normalizePollingResponse = normalizePollingResponse;
exports.pluginRegistry = pluginRegistry;
exports.query = query;
exports.serialize = serialize;
exports.serviceEndpoint = serviceEndpoint;
exports.setIsReactNative = setIsReactNative;
exports.tx = transaction;
exports.verifyUserSignatures = verifyUserSignatures;
//# sourceMappingURL=fcl-core.js.map
