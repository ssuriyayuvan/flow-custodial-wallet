/**
 * @callback SubscriptionCallback
 * @param {TransactionStatus} txStatus
 * @returns {void}
 */
/**
 * Provides methods for interacting with a transaction
 *
 * @param {string} transactionId - The transaction ID
 * @param {object} [opts] - Optional parameters
 * @param {number} [opts.pollRate=2500] - Polling rate in milliseconds
 * @param {number} [opts.txNotFoundTimeout=12500] - Timeout in milliseconds for ignoring transaction not found errors (do not modify unless you know what you are doing)
 * @returns {{
 *    snapshot: function(): Promise<TransactionStatus>,
 *    subscribe: function(SubscriptionCallback): function(): void,
 *    onceFinalized: function(): Promise<TransactionStatus>,
 *    onceExecuted: function(): Promise<TransactionStatus>,
 *    onceSealed: function(): Promise<TransactionStatus>
 * }}
 * @throws {Error} If transactionId is not a 64 byte hash string
 */
export function transaction(transactionId: string, opts?: {
    pollRate?: number | undefined;
    txNotFoundTimeout?: number | undefined;
} | undefined): {
    snapshot: () => Promise<TransactionStatus>;
    subscribe: (arg0: SubscriptionCallback) => () => void;
    onceFinalized: () => Promise<TransactionStatus>;
    onceExecuted: () => Promise<TransactionStatus>;
    onceSealed: () => Promise<TransactionStatus>;
};
export namespace transaction {
    export { isUnknown };
    export { isPending };
    export { isFinalized };
    export { isExecuted };
    export { isSealed };
    export { isExpired };
}
export type SubscriptionCallback = (txStatus: TransactionStatus) => void;
export type Transaction = import("@onflow/typedefs").Transaction;
export type TransactionStatus = import("@onflow/typedefs").TransactionStatus;
declare function isUnknown(tx: any): boolean;
declare function isPending(tx: any): boolean;
declare function isFinalized(tx: any): boolean;
declare function isExecuted(tx: any): boolean;
declare function isSealed(tx: any): boolean;
declare function isExpired(tx: any): boolean;
export {};
