import { spawn, SUBSCRIBE, UNSUBSCRIBE, send, subscriber } from '@onflow/util-actor';
import * as logger from '@onflow/util-logger';
import { invariant } from '@onflow/util-invariant';

const pipe = function () {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }
  return v => {
    return funcs.reduce((res, func) => {
      return func(res);
    }, v);
  };
};

/***
 * Merge multiple functions returning objects into one object.
 * @param funcs - Functions to merge
 * @return Merged object
 */
const mergePipe = function () {
  for (var _len2 = arguments.length, funcs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    funcs[_key2] = arguments[_key2];
  }
  return v => {
    return funcs.reduce((res, func) => {
      return {
        ...res,
        ...func(v)
      };
    }, {});
  };
};

/**
 * @description Object check
 * @param value - Value to check
 * @returns Is object status
 */
const isObject = value => value && typeof value === "object" && !Array.isArray(value);

/**
 * @description Deep merge multiple objects.
 * @param target - Target object
 * @param sources - Source objects
 * @returns Merged object
 */
const mergeDeep = function (target) {
  for (var _len3 = arguments.length, sources = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    sources[_key3 - 1] = arguments[_key3];
  }
  if (!sources.length) return target;
  const source = sources.shift();
  if (isObject(target) && isObject(source)) {
    for (const key in source) {
      if (isObject(source[key])) {
        if (!target[key]) Object.assign(target, {
          [key]: {}
        });
        mergeDeep(target[key], source[key]);
      } else {
        Object.assign(target, {
          [key]: source[key]
        });
      }
    }
  }
  return mergeDeep(target, ...sources);
};

/**
 * @description Deep merge multiple Flow JSON.
 * @param value - Flow JSON or array of Flow JSONs
 * @returns Merged Flow JSON
 */
const mergeFlowJSONs = value => Array.isArray(value) ? mergeDeep({}, ...value) : value;

/**
 * @description Filter out contracts section of flow.json.
 * @param obj - Flow JSON
 * @returns Contracts section of Flow JSON
 */
const filterContracts = obj => obj.contracts ? obj.contracts : {};

/**
 * @description Filter out dependencies section of flow.json.
 * @param obj - Flow JSON
 * @returns Dependencies section of Flow JSON
 */
const filterDependencies = obj => obj.dependencies ? obj.dependencies : {};

/**
 * @description Gathers contract addresses by network
 * @param network - Network to gather addresses for
 * @returns Contract names by addresses mapping e.g { "HelloWorld": "0x123" }
 */
const mapContractAliasesToNetworkAddress = network => contracts => {
  return Object.entries(contracts).reduce((c, _ref) => {
    let [key, value] = _ref;
    const networkContractAlias = value?.aliases?.[network];
    if (networkContractAlias) {
      c[key] = networkContractAlias;
    }
    return c;
  }, {});
};

/**
 * @description Gathers dependency addresses by network
 * @param network - Network to gather addresses for
 * @returns Dependency names by addresses mapping e.g { "HelloWorld": "0x123" }
 */
const mapDependencyAliasesToNetworkAddress = network => dependencies => {
  return Object.entries(dependencies).reduce((c, _ref2) => {
    let [key, value] = _ref2;
    const networkDependencyAlias = value?.aliases?.[network];
    if (networkDependencyAlias) {
      c[key] = networkDependencyAlias;
    }
    return c;
  }, {});
};
const mapDeploymentsToNetworkAddress = network => _ref3 => {
  let {
    deployments = {},
    accounts = {}
  } = _ref3;
  const networkDeployment = deployments?.[network];
  if (!networkDeployment) return {};
  return Object.entries(networkDeployment).reduce((c, _ref4) => {
    let [key, value] = _ref4;
    // Resolve account address
    const accountAddress = accounts[key]?.address;
    if (!accountAddress) return c;

    // Create an object assigning the address to the contract name.
    return value.reduce((c, contract) => {
      return {
        ...c,
        [contract]: accountAddress
      };
    }, {});
  }, {});
};

/**
 * @description Take in flow.json files and return contract to address mapping by network
 * @param jsons - Flow JSON or array of Flow JSONs
 * @param network - Network to gather addresses for
 * @returns Contract names by addresses mapping e.g { "HelloWorld": "0x123" }
 */
const getContracts = (jsons, network) => {
  return pipe(mergeFlowJSONs, mergePipe(mapDeploymentsToNetworkAddress(network), pipe(filterContracts, mapContractAliasesToNetworkAddress(network)), pipe(filterDependencies, mapDependencyAliasesToNetworkAddress(network))))(jsons);
};

/**
 * @description Checks if string is hexidecimal
 * @param str - String to check
 * @returns Is hexidecimal status
 */
const isHexidecimal = str => {
  // Check that it is a string
  if (typeof str !== "string") return false;
  return /^[0-9A-Fa-f]+$/.test(str);
};

/**
 * @description Checks flow.json file for private keys
 * @param flowJSON - Flow JSON
 * @returns Has private keys status
 */
const hasPrivateKeys = flowJSON => {
  return Object.entries(flowJSON?.accounts ?? []).reduce((hasPrivateKey, _ref5) => {
    let [, value] = _ref5;
    if (hasPrivateKey) return true;
    return value && Object.prototype.hasOwnProperty.call(value, "key") && isHexidecimal(value?.key);
  }, false);
};

/**
 * @description Take in flow.json or array of flow.json files and checks for private keys
 * @param value - Flow JSON or array of Flow JSONs
 * @returns Has private keys status
 */
const anyHasPrivateKeys = value => {
  if (Array.isArray(value)) return value.some(hasPrivateKeys);
  return hasPrivateKeys(value);
};

/**
 * @description Format network to always be 'emulator', 'testnet', 'previewnet' or 'mainnet'
 * @param network - Network to format
 * @returns Formatted network name (either 'emulator', 'testnet', 'previewnet' or 'mainnet')
 */
const cleanNetwork = network => {
  const cleanedNetwork = network?.toLowerCase() === "local" ? "emulator" : network?.toLowerCase();
  if (cleanedNetwork === "emulator" || cleanedNetwork === "testnet" || cleanedNetwork === "mainnet" || cleanedNetwork === "previewnet") return cleanedNetwork;
  throw new Error(`Invalid network "${network}". Must be one of "emulator", "local", "testnet", or "mainnet"`);
};

// Inject config into logger to break circular dependency
logger.setConfig(config);
const NAME = "config";
const PUT = "PUT_CONFIG";
const GET = "GET_CONFIG";
const GET_ALL = "GET_ALL_CONFIG";
const UPDATE = "UPDATE_CONFIG";
const DELETE = "DELETE_CONFIG";
const CLEAR = "CLEAR_CONFIG";
const WHERE = "WHERE_CONFIG";
const UPDATED = "CONFIG/UPDATED";
const identity = v => v;
const HANDLERS = {
  [PUT]: (ctx, _letter, _ref) => {
    let {
      key,
      value
    } = _ref;
    if (key == null) throw new Error("Missing 'key' for config/put.");
    ctx.put(key, value);
    ctx.broadcast(UPDATED, {
      ...ctx.all()
    });
  },
  [GET]: (ctx, letter, _ref2) => {
    let {
      key,
      fallback
    } = _ref2;
    if (key == null) throw new Error("Missing 'key' for config/get");
    letter.reply(ctx.get(key, fallback));
  },
  [GET_ALL]: (ctx, letter) => {
    letter.reply({
      ...ctx.all()
    });
  },
  [UPDATE]: (ctx, letter, _ref3) => {
    let {
      key,
      fn
    } = _ref3;
    if (key == null) throw new Error("Missing 'key' for config/update");
    ctx.update(key, fn || identity);
    ctx.broadcast(UPDATED, {
      ...ctx.all()
    });
  },
  [DELETE]: (ctx, letter, _ref4) => {
    let {
      key
    } = _ref4;
    if (key == null) throw new Error("Missing 'key' for config/delete");
    ctx.delete(key);
    ctx.broadcast(UPDATED, {
      ...ctx.all()
    });
  },
  [CLEAR]: ctx => {
    const keys = Object.keys(ctx.all());
    for (const key of keys) ctx.delete(key);
    ctx.broadcast(UPDATED, {
      ...ctx.all()
    });
  },
  [WHERE]: (ctx, letter, _ref5) => {
    let {
      pattern
    } = _ref5;
    if (pattern == null) throw new Error("Missing 'pattern' for config/where");
    letter.reply(ctx.where(pattern));
  },
  [SUBSCRIBE]: (ctx, letter) => {
    ctx.subscribe(letter.from);
    ctx.send(letter.from, UPDATED, {
      ...ctx.all()
    });
  },
  [UNSUBSCRIBE]: (ctx, letter) => {
    ctx.unsubscribe(letter.from);
  }
};
spawn(HANDLERS, NAME);

/**
 * @description Adds a key-value pair to the config
 * @param key - The key to add
 * @param value - The value to add
 * @returns The config object
 */
function put(key, value) {
  send(NAME, PUT, {
    key,
    value
  });
  return config();
}

/**
 * @description Gets a key-value pair with a fallback from the config
 * @param key - The key to add
 * @param fallback - The fallback value to return if key is not found
 * @returns The value found at key or fallback
 */
function get(key, fallback) {
  return send(NAME, GET, {
    key,
    fallback
  }, {
    expectReply: true,
    timeout: 10
  });
}

/**
 * @description Returns the first non null config value or the fallback
 * @param wants - The keys to search for
 * @param fallback - The fallback value to return if key is not found
 * @returns The value found at key or fallback
 */
async function first() {
  let wants = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  let fallback = arguments.length > 1 ? arguments[1] : undefined;
  if (!wants.length) return fallback;
  const [head, ...rest] = wants;
  const ret = await get(head);
  if (ret == null) return first(rest, fallback);
  return ret;
}

/**
 * @description Returns the current config
 * @returns The config object
 */
function all() {
  return send(NAME, GET_ALL, null, {
    expectReply: true,
    timeout: 10
  });
}

/**
 * @description Updates a key-value pair in the config
 * @param key - The key to update
 * @param fn - The function to update the value with
 * @returns The config object
 */
function update(key) {
  let fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;
  send(NAME, UPDATE, {
    key,
    fn
  });
  return config();
}

/**
 * @description Deletes a key-value pair from the config
 * @param key - The key to delete
 * @returns The config object
 */
function _delete(key) {
  send(NAME, DELETE, {
    key
  });
  return config();
}

/**
 * @description Returns a subset of the config based on a pattern
 * @param pattern - The pattern to match keys against
 * @returns The subset of the config
 */
function where(pattern) {
  return send(NAME, WHERE, {
    pattern
  }, {
    expectReply: true,
    timeout: 10
  });
}

/**
 * @description Subscribes to config updates
 * @param callback - The callback to call when config is updated
 * @returns The unsubscribe function
 */
function subscribe(callback) {
  return subscriber(NAME, () => spawn(HANDLERS, NAME), callback);
}

/**
 * @description Clears the config
 */
async function clearConfig() {
  await send(NAME, CLEAR);
}

/**
 * @description Resets the config to a previous state
 * @param oldConfig - The previous config state
 * @returns The config object
 */
async function resetConfig(oldConfig) {
  return clearConfig().then(() => config(oldConfig));
}

/**
 * @description Takes in flow.json or array of flow.json files and creates contract placeholders
 * @param data - The data to load
 * @param data.flowJSON - The flow.json or array of flow.json files
 */
async function load(data) {
  const network = await get("flow.network");
  const cleanedNetwork = cleanNetwork(network);
  const {
    flowJSON
  } = data;
  invariant(Boolean(flowJSON), "config.load -- 'flowJSON' must be defined");
  invariant(!!cleanedNetwork, `Flow Network Required -- In order for FCL to load your contracts please define "flow.network" to "emulator", "local", "testnet", or "mainnet" in your config. See more here: https://developers.flow.com/tools/fcl-js/reference/configure-fcl`);
  if (anyHasPrivateKeys(flowJSON)) {
    const isEmulator = cleanedNetwork === "emulator";
    logger.log({
      title: "Private Keys Detected",
      message: `Private keys should be stored in a separate flow.json file for security. See more here: https://developers.flow.com/tools/flow-cli/security`,
      level: isEmulator ? logger.LEVELS.warn : logger.LEVELS.error
    });
    invariant(isEmulator, `Private keys should be stored in a separate flow.json file for security. See more here: https://developers.flow.com/tools/flow-cli/security`);
  }
  for (const [key, value] of Object.entries(getContracts(flowJSON, cleanedNetwork))) {
    const contractConfigKey = `0x${key}`;
    const existingContractConfigKey = await get(contractConfigKey);
    if (existingContractConfigKey && existingContractConfigKey !== value) {
      logger.log({
        title: "Contract Placeholder Conflict Detected",
        message: `A generated contract placeholder from config.load conflicts with a placeholder you've set manually in config have the same name.`,
        level: logger.LEVELS.warn
      });
    } else {
      put(contractConfigKey, value);
    }
    const systemContractConfigKey = `system.contracts.${key}`;
    const systemExistingContractConfigKeyValue = await get(systemContractConfigKey);
    if (systemExistingContractConfigKeyValue && systemExistingContractConfigKeyValue !== value) {
      logger.log({
        title: "Contract Placeholder Conflict Detected",
        message: `A generated contract placeholder from config.load conflicts with a placeholder you've set manually in config have the same name.`,
        level: logger.LEVELS.warn
      });
    } else {
      put(systemContractConfigKey, value);
    }
  }
}

/**
 * @description Sets the config
 * @param values - The values to set
 * @returns The config object
 */
function config(values) {
  if (values != null && typeof values === "object") {
    Object.keys(values).map(d => put(d, values[d]));
  }
  return {
    put,
    get,
    all,
    first,
    update,
    delete: _delete,
    where,
    subscribe,
    overload,
    load
  };
}
config.put = put;
config.get = get;
config.all = all;
config.first = first;
config.update = update;
config.delete = _delete;
config.where = where;
config.subscribe = subscribe;
config.overload = overload;
config.load = load;

/**
 * @description Temporarily overloads the config with the given values and calls the callback
 * @param values - The values to overload the config with
 * @param callback - The callback to call with the overloaded config
 * @returns The result of the callback
 */
async function overload(values, callback) {
  const oldConfig = await all();
  try {
    config(values);
    const result = await callback(await all());
    return result;
  } finally {
    await resetConfig(oldConfig);
  }
}

export { clearConfig, config };
//# sourceMappingURL=config.module.js.map
