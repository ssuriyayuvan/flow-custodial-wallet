/**
 * @description Adds a key-value pair to the config
 * @param key - The key to add
 * @param value - The value to add
 * @returns The config object
 */
declare function put<T>(key: string, value: T): {
    put: typeof put;
    get: typeof get;
    all: typeof all;
    first: typeof first;
    update: typeof update;
    delete: typeof _delete;
    where: typeof where;
    subscribe: typeof subscribe;
    overload: typeof overload;
    load: typeof load;
};
/**
 * @description Gets a key-value pair with a fallback from the config
 * @param key - The key to add
 * @param fallback - The fallback value to return if key is not found
 * @returns The value found at key or fallback
 */
declare function get<T>(key: string, fallback?: T): Promise<T>;
/**
 * @description Returns the first non null config value or the fallback
 * @param wants - The keys to search for
 * @param fallback - The fallback value to return if key is not found
 * @returns The value found at key or fallback
 */
declare function first<T>(wants: string[] | undefined, fallback: T): Promise<T>;
/**
 * @description Returns the current config
 * @returns The config object
 */
declare function all(): Promise<Record<string, unknown>>;
/**
 * @description Updates a key-value pair in the config
 * @param key - The key to update
 * @param fn - The function to update the value with
 * @returns The config object
 */
declare function update<T>(key: string, fn?: (x: T) => T): {
    put: typeof put;
    get: typeof get;
    all: typeof all;
    first: typeof first;
    update: typeof update;
    delete: typeof _delete;
    where: typeof where;
    subscribe: typeof subscribe;
    overload: typeof overload;
    load: typeof load;
};
/**
 * @description Deletes a key-value pair from the config
 * @param key - The key to delete
 * @returns The config object
 */
declare function _delete(key: string): {
    put: typeof put;
    get: typeof get;
    all: typeof all;
    first: typeof first;
    update: typeof update;
    delete: typeof _delete;
    where: typeof where;
    subscribe: typeof subscribe;
    overload: typeof overload;
    load: typeof load;
};
/**
 * @description Returns a subset of the config based on a pattern
 * @param pattern - The pattern to match keys against
 * @returns The subset of the config
 */
declare function where(pattern: RegExp): Promise<Record<string, unknown>>;
/**
 * @description Subscribes to config updates
 * @param callback - The callback to call when config is updated
 * @returns The unsubscribe function
 */
declare function subscribe(callback: (config: Record<string, unknown> | null, error: Error | null) => void): () => void;
/**
 * @description Clears the config
 */
export declare function clearConfig(): Promise<void>;
/**
 * @description Takes in flow.json or array of flow.json files and creates contract placeholders
 * @param data - The data to load
 * @param data.flowJSON - The flow.json or array of flow.json files
 */
declare function load(data: {
    flowJSON: Record<string, unknown> | Record<string, unknown>[];
}): Promise<void>;
/**
 * @description Sets the config
 * @param values - The values to set
 * @returns The config object
 */
declare function config(values?: Record<string, unknown>): {
    put: typeof put;
    get: typeof get;
    all: typeof all;
    first: typeof first;
    update: typeof update;
    delete: typeof _delete;
    where: typeof where;
    subscribe: typeof subscribe;
    overload: typeof overload;
    load: typeof load;
};
declare namespace config {
    export var put: <T>(key: string, value: T) => {
        put: any;
        get: <T_1>(key: string, fallback?: T_1 | undefined) => Promise<T_1>;
        all: () => Promise<Record<string, unknown>>;
        first: <T_2>(wants: string[] | undefined, fallback: T_2) => Promise<T_2>;
        update: <T_3>(key: string, fn?: (x: T_3) => T_3) => any;
        delete: typeof _delete;
        where: (pattern: RegExp) => Promise<Record<string, unknown>>;
        subscribe: (callback: (config: Record<string, unknown> | null, error: Error | null) => void) => () => void;
        overload: <T_4>(values: Record<string, unknown>, callback: (oldConfig: Record<string, unknown>) => T_4) => Promise<T_4>;
        load: (data: {
            flowJSON: Record<string, unknown> | Record<string, unknown>[];
        }) => Promise<void>;
    };
    export var get: <T>(key: string, fallback?: T | undefined) => Promise<T>;
    export var all: () => Promise<Record<string, unknown>>;
    export var first: <T>(wants: string[] | undefined, fallback: T) => Promise<T>;
    export var update: <T>(key: string, fn?: (x: T) => T) => {
        put: <T_1>(key: string, value: T_1) => any;
        get: <T_2>(key: string, fallback?: T_2 | undefined) => Promise<T_2>;
        all: () => Promise<Record<string, unknown>>;
        first: <T_3>(wants: string[] | undefined, fallback: T_3) => Promise<T_3>;
        update: any;
        delete: typeof _delete;
        where: (pattern: RegExp) => Promise<Record<string, unknown>>;
        subscribe: (callback: (config: Record<string, unknown> | null, error: Error | null) => void) => () => void;
        overload: <T_4>(values: Record<string, unknown>, callback: (oldConfig: Record<string, unknown>) => T_4) => Promise<T_4>;
        load: (data: {
            flowJSON: Record<string, unknown> | Record<string, unknown>[];
        }) => Promise<void>;
    };
    var _a: typeof _delete;
    export var where: (pattern: RegExp) => Promise<Record<string, unknown>>;
    export var subscribe: (callback: (config: Record<string, unknown> | null, error: Error | null) => void) => () => void;
    export var overload: <T>(values: Record<string, unknown>, callback: (oldConfig: Record<string, unknown>) => T) => Promise<T>;
    export var load: (data: {
        flowJSON: Record<string, unknown> | Record<string, unknown>[];
    }) => Promise<void>;
    export { _a as delete };
}
export { config };
/**
 * @description Temporarily overloads the config with the given values and calls the callback
 * @param values - The values to overload the config with
 * @param callback - The callback to call with the overloaded config
 * @returns The result of the callback
 */
declare function overload<T>(values: Record<string, unknown>, callback: (oldConfig: Record<string, unknown>) => T): Promise<T>;
